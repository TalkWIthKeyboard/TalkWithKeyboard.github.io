<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Spark Memory Management | GRYFFONDOR</title>
  <meta name="author" content="TalkWithKeyboard">
  
  <meta name="description" content="æœ¬æ–‡ä¸»è¦æ˜¯å¯¹Sparkçš„å†…å­˜ç®¡ç†æ¨¡å—è¿›è¡Œäº†ä»£ç èµ°è¯»ï¼Œä»ä¸šåŠ¡é€»è¾‘ä¸ŠSparkå°†å†…å­˜åˆ’åˆ†ä¸ºæ‰§è¡ŒåŒºï¼ˆExecutionåŒºï¼Œå†…å­˜ä¸»è¦ç”¨æ¥è¿›è¡Œshuffleï¼Œjoinï¼Œsortï¼Œaggregateçš„è®¡ç®—ï¼‰ã€å­˜å‚¨åŒºï¼ˆStorageåŒºï¼Œå†…å­˜ä¸»è¦ç”¨æ¥è¿›è¡Œç¼“å­˜å’Œdata transferï¼‰ã€‚ä¸ºäº†ä¼˜åŒ–JVMå†…å­˜ç³»ç»Ÿçš„ä¸€">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Spark Memory Management">
  <meta property="og:site_name" content="GRYFFONDOR">

  
    <meta property="og:image" content>
  

  
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">GRYFFONDOR</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Spark Memory Management</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>æœ¬æ–‡ä¸»è¦æ˜¯å¯¹Sparkçš„å†…å­˜ç®¡ç†æ¨¡å—è¿›è¡Œäº†ä»£ç èµ°è¯»ï¼Œä»ä¸šåŠ¡é€»è¾‘ä¸ŠSparkå°†å†…å­˜åˆ’åˆ†ä¸ºæ‰§è¡ŒåŒºï¼ˆExecutionåŒºï¼Œå†…å­˜ä¸»è¦ç”¨æ¥è¿›è¡Œshuffleï¼Œjoinï¼Œsortï¼Œaggregateçš„è®¡ç®—ï¼‰ã€å­˜å‚¨åŒºï¼ˆStorageåŒºï¼Œå†…å­˜ä¸»è¦ç”¨æ¥è¿›è¡Œç¼“å­˜å’Œdata transferï¼‰ã€‚ä¸ºäº†ä¼˜åŒ–JVMå†…å­˜ç³»ç»Ÿçš„ä¸€äº›é—®é¢˜ï¼Œåœ¨å †å†…å­˜å’Œå †å¤–å†…å­˜çš„åŸºç¡€ä¸ŠæŠ½è±¡äº†Tungstenå†…å­˜ç³»ç»Ÿã€‚æ–‡ä¸­å¯¹æ¶‰åŠåˆ°çš„å†…çš„å…³é”®æ–¹æ³•è¿›è¡Œäº†åˆ†æã€‚</p>
<h2 id="ä»£ç æ¸…å•"><a href="#ä»£ç æ¸…å•" class="headerlink" title="ä»£ç æ¸…å•"></a>ä»£ç æ¸…å•</h2><ul>
<li>org.apache.spark.memory.MemoryManager</li>
<li>org.apache.spark.memory.UnifiedMemoryManager</li>
<li>org.apache.spark.memory.MemoryPool</li>
<li>org.apache.spark.memory.ExecutionMemoryPool</li>
<li>org.apache.spark.memory.StorageMemoryPool</li>
<li>org.apache.spark.memory.MemoryConsumer</li>
<li>org.apache.spark.memory.TaskMemoryManager</li>
<li>org.apache.spark.unsafe.memory.MemoryLocation</li>
<li>org.apache.spark.unsafe.memory.MemoryBlock</li>
<li>org.apache.spark.unsafe.memory.MemoryAllocator</li>
<li>org.apache.spark.unsafe.memory.HeapMemoryAllocator</li>
<li>org.apache.spark.unsafe.memory.UnsafeMemoryAllocator</li>
<li>org.apache.spark.storage.memory.MemoryStore</li>
</ul>
<h2 id="æ€»è§ˆ"><a href="#æ€»è§ˆ" class="headerlink" title="æ€»è§ˆ"></a>æ€»è§ˆ</h2><p><img src="/images/a18-1.jpg" alt="a18-1"><br>å…¨å±€åªæœ‰å”¯ä¸€ä¸€ä¸ªMemoryManagerï¼Œé‡Œé¢ç»´æŠ¤äº†4ä¸ªPoolã€‚ä»ä¸šåŠ¡ä¸Šåˆ†ä¸ºExecutionå’ŒStorageï¼Œä»å­˜å‚¨ä½ç½®åˆ†ä¸ºOnHeapå’ŒOffHeapã€‚æ¯ä¸ªtaskéœ€è¦ä½¿ç”¨å¤šä¸ªæ•°æ®ç»“æ„ï¼Œæ¯ä¸ªæ•°æ®ç»“æ„éƒ½æ˜¯ä¸€ä¸ª<code>MemoryConsumer</code>çš„å®ç°ï¼Œæ¯ä¸ªtaskçš„è¿™äº›consumeréƒ½é€šè¿‡<code>TaskMemoryManager</code>è¿›è¡Œç®¡ç†ï¼Œå¤šä¸ª<code>TaskMemoryManager</code>å…±åŒç»´æŠ¤ä¸€ä¸ª<code>Tungsten</code>çš„é¡µç»“æ„ã€‚</p>
<h2 id="Tungsten"><a href="#Tungsten" class="headerlink" title="Tungsten"></a>Tungsten</h2><p>ä¸ºäº†è§£å†³JVMå¯¹è±¡å­˜å‚¨æ—¶çš„overheadé—®é¢˜ï¼Œä»¥åŠGCé€ æˆçš„æ€§èƒ½æŸè€—ï¼Œè€Œæå‡ºäº†ä¸€ä¸ªæ–°çš„å†…å­˜æ¨¡å‹ã€‚æä¾›ä¸€å¥—åƒC/C++ä¸€æ ·å¯ä»¥ç›´æ¥æ“ä½œå†…å­˜çš„æ¥å£ï¼ˆå®é™…æ“ä½œçš„æ˜¯å †å¤–å†…å­˜ï¼‰ï¼Œå†ä¸ºäº†é€šç”¨æ€§æä¾›äº†æ›´é«˜å±‚çš„æ¥å£å°†å †å†…å­˜å’Œå †å¤–å†…å­˜è¿›è¡Œäº†ç»Ÿä¸€ã€‚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Object obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MemoryLocation</span><span class="params">(@Nullable Object obj, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MemoryLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjAndOffset</span><span class="params">(Object newObj, <span class="keyword">long</span> newOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.obj = newObj;</span><br><span class="line">    <span class="keyword">this</span>.offset = newOffset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getBaseObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getBaseOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryBlock</span> <span class="keyword">extends</span> <span class="title">MemoryLocation</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> length;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> pageNumber = NO_PAGE_NUMBER;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tungstenæä¾›äº†ä¸€å¥—ç±»ä¼¼æ“ä½œç³»ç»Ÿé¡µå†…å­˜ç®¡ç†ä¸€æ ·çš„ç»“æ„ï¼Œæ¯é¡µä¼šå­˜å‚¨ä¸€ä¸ª<code>MemoryBlock</code>ç»“æ„ã€‚<br><code>length</code>æ˜¯æ•´ä¸ªBlockå®é™…å ç”¨çš„å†…å­˜å¤§å°ï¼Œ<code>pageNumber</code>æ˜¯åœ¨é¡µæ•°ç»„ä¸­çš„indexä½ç½®ã€‚<code>MemoryLocation</code>ç»Ÿä¸€äº†å †å†…å¤–å†…å­˜çš„å¯»å€ï¼Œå¦‚æœæ˜¯off-heapï¼Œåˆ™<code>obj</code>ä¸ºnullï¼Œ<code>offset</code>ä¸ºç»å¯¹å†…å­˜åœ°å€ï¼›å¦‚æœæ˜¯on-heapï¼Œåˆ™<code>obj</code>ä¸ºå¯¹è±¡çš„åŸºåœ°å€ï¼Œ<code>offset</code>ä¸ºåç§»é‡ã€‚æ‰€ä»¥åœ¨å®é™…ä½¿ç”¨è¿‡ç¨‹å½“ä¸­å°±éœ€è¦åœ¨ç‰©ç†åœ°å€ä¸<code>pageNumber</code>,<code>offsetInPage</code>ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼š</p>
<ul>
<li>on-heap: <code>address = page.obj + page.offset + inPageOffset</code></li>
<li>off-heap: <code>address = page.offset + inPageOffset</code></li>
</ul>
<p>ä½†æ˜¯åœ¨è¿™å¥—ç»“æ„ä¸­ç‰©ç†åœ°å€ä¸ä¼šç›´æ¥çš„å­˜å‚¨ï¼Œ<code>pageNumer</code> + <code>offsetInPage</code>çš„ç»„åˆå°±èƒ½å”¯ä¸€çš„å®šä½ä¸€ä¸ªå€¼çš„ä½ç½®ï¼Œæ‰€ä»¥æä¾›äº†ä¸€ä¸ªç¼–ç æ–¹æ³•ç”¨64ä½çš„longå€¼å­˜å‚¨è¿™ä¸ªåæ ‡ï¼Œå‰13ä½æ˜¯pageNumberï¼Œå51ä½æ˜¯inPageOffsetã€‚åœ¨<code>TaskMemoryManager</code>å½“ä¸­æä¾›äº†å¤šä¸ªè½¬æ¢çš„æ–¹æ³•ï¼š</p>
<ul>
<li><code>long encodePageNumberAndOffset(MemoryBlock page, long offsetInPage)</code>ï¼šç»™å®šé¡µå’Œé¡µå†…åç§»é‡è®¡ç®—encodeå€¼</li>
<li><code>long encodePageNumberAndOffset(int pageNumer, long offsetInPage)</code>ï¼šç»™å®šé¡µå·å’Œé¡µå†…åç§»é‡è®¡ç®—encodeå€¼</li>
<li><code>int decodePageNumber(long pagePlusOffsetAddress)</code>ï¼šç»™å®šencodeå€¼ï¼Œè§£ç pageNumber</li>
<li><code>long decodeOffset(long pagePlusOffsetAddress)</code>ï¼šç»™å®šencodeå€¼ï¼Œè§£ç offset</li>
<li><code>Object getPage(long pagePlusOffsetAddress)</code>ï¼šç»™å®šencodeå€¼ï¼Œè·å–é¡µ</li>
<li><code>long getOffsetInPage(long pagePlusOffsetAddress)</code>ï¼šç»™å®šencodeå€¼ï¼Œè·å–é¡µå†…åç§»</li>
</ul>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><h3 id="MemoryManager"><a href="#MemoryManager" class="headerlink" title="MemoryManager"></a>MemoryManager</h3><p>è¯¥ç±»æ˜¯å†…å­˜ç®¡ç†çš„ç»Ÿç­¹ç±»ï¼Œå®šä¹‰äº†æ‰€æœ‰çš„å†…å­˜ç®¡ç†åŠ¨ä½œã€‚å› ä¸ºæ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œæ‰€ä»¥è¿™äº›åŠ¨ä½œæœ‰çš„ä¼šä¸‹æ”¾ç»™å®ç°ç±»å®ç°ï¼Œæœ‰äº›åŠ¨ä½œä¼šå§”æ‰˜<code>MemoryPool</code>ç±»å®ç°ã€‚ä¸‹é¢æ˜¯æ¥å£çš„åˆ†ç±»ï¼š</p>
<ul>
<li><p>è·å–å†…å­˜å¤§å°ï¼š</p>
<ul>
<li><code>abstract maxOnHeapStorageMemory</code>ï¼šè·å–StorageåŒºæœ€å¤§èƒ½ä½¿ç”¨çš„å †å†…å­˜å¤§å°ï¼ˆåŠ¨æ€å˜åŒ–çš„ï¼‰</li>
<li><code>abstract maxOffHeapStorageMemory</code>ï¼šè·å–StorageåŒºæœ€å¤§èƒ½ä½¿ç”¨çš„å †å¤–å†…å­˜å¤§å°ï¼ˆåŠ¨æ€å˜åŒ–çš„ï¼‰</li>
<li><code>storageMemoryUsed</code>: StorageåŒºå·²ä½¿ç”¨çš„å†…å­˜å¤§å°</li>
<li><code>onHeapStorageMemoryUsed</code>ï¼šStorageåŒºå·²ä½¿ç”¨çš„å †å†…å­˜å¤§å°</li>
<li><code>offHeapStorageMemoryUsed</code>ï¼šStorageåŒºå·²ä½¿ç”¨çš„å †å¤–å†…å­˜å¤§å°</li>
<li><code>executionMemoryUsed</code>: ExecutionåŒºå·²ä½¿ç”¨çš„å†…å­˜å¤§å°</li>
<li><code>onHeapExecutionMemoryUsed</code>ï¼šExecutionåŒºå·²ä½¿ç”¨çš„å †å†…å­˜å¤§å°</li>
<li><code>offHeapExecutionMemoryUsed</code>ï¼šExecutionåŒºå·²ä½¿ç”¨çš„å †å¤–å†…å­˜å¤§å°</li>
<li><code>getExecutionMemoryUsageForTask</code>ï¼šè·å–ä¸€ä¸ªtaskåœ¨ExecutionåŒºå ç”¨çš„å†…å­˜å¤§å°</li>
</ul>
</li>
<li><p>è·å–æ›´å¤šçš„å†…å­˜ç©ºé—´ï¼š</p>
<ul>
<li><code>abstract acquireStorageMemory(blockId: BlockId, numBytes: Long, memoryMode: MemoryMode)</code>ï¼šä¸ºä¸€ä¸ªBlockè·å–<code>numBytes</code>çš„StorageåŒºå†…å­˜ç©ºé—´ï¼Œå¦‚æœè·å–ä¸åˆ°è¶³å¤Ÿçš„ç©ºé—´å¯èƒ½ä¼šåˆ é™¤ä¸€ä¸ªå­˜åœ¨çš„Blockã€‚</li>
<li><code>abstract acquireExecutionMemory(numBytes: Long, taskAttemptId: Long, memoryMode: MemoryMode)</code>ï¼šä¸ºä¸€ä¸ªtaskè·å–<code>numBytes</code>çš„ExecutionåŒºå†…å­˜ç©ºé—´ï¼Œå½“ä¸èƒ½è·å–åˆ°è¶³å¤Ÿæ‰§è¡Œçš„å†…å­˜ç©ºé—´æ—¶ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šé˜»å¡ï¼Œç›´åˆ°è·å–åˆ°è¶³å¤Ÿå¤šçš„å†…å­˜ã€‚</li>
</ul>
</li>
<li><p>é‡Šæ”¾å†…å­˜ç©ºé—´ï¼š</p>
<ul>
<li><code>releaseAllExecutionMemoryForTask(taskAttemptId: Long)</code>ï¼šé‡Šæ”¾ä¸€ä¸ªtaskå ç”¨çš„æ‰€æœ‰ExecutionåŒºå†…å­˜ç©ºé—´</li>
<li><code>releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode)</code>ï¼šé‡Šæ”¾<code>numBytes</code>çš„StorageåŒºå†…å­˜ç©ºé—´</li>
<li><code>releaseAllStorageMemory()</code>ï¼šé‡Šæ”¾æ‰€æœ‰çš„StorageåŒºå†…å­˜ç©ºé—´</li>
<li><code>releaseUnrollMemory(numBytes: Long, memoryMode: MemoryMode)</code>ï¼šé‡Šæ”¾<code>numBytes</code>çš„ç”¨äºunroll blockçš„å†…å­˜ç©ºé—´</li>
</ul>
</li>
<li><p><code>Tungsten</code>ç›¸å…³</p>
</li>
</ul>
<h3 id="UnifiedMemoryManager"><a href="#UnifiedMemoryManager" class="headerlink" title="UnifiedMemoryManager"></a>UnifiedMemoryManager</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">UnifiedMemoryManager</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val maxHeapMemory: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    onHeapStorageRegionSize: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    numCores: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>æ„é€ å‡½æ•°ä¸­çš„ï¼š</p>
<ul>
<li><code>maxHeapMemory</code>ï¼šæ˜¯å †å†…å­˜çš„æ€»å¤§å°</li>
<li><code>onHeapStorageRegionSize</code>ï¼šæ˜¯å †å†…å­˜ä¸­StorageåŒºçš„èµ·å§‹å¤§å°</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">maxOnHeapStorageMemory</span></span>: <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">  maxHeapMemory - onHeapExecutionMemoryPool.memoryUsed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">maxOffHeapStorageMemory</span></span>: <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">  maxOffHeapMemory - offHeapExecutionMemoryPool.memoryUsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™ä¸¤ä¸ªæ–¹æ³•å°±æ˜¯ç®€å•çš„è®¡ç®—ï¼Œä¸è¿‡<code>maxHeapMemory</code>æ˜¯åˆ›å»º<code>UnifiedMemoryManager</code>æ—¶ä¼ å…¥çš„å‚æ•°ï¼Œè€Œ<code>maxOffHeapMemory</code>æ˜¯ä»<code>spark.memory.offHeap.size</code>å‚æ•°ä¸­è¯»å…¥ã€‚</p>
<p>::acquireExecutionMemory::<br><code>acquireExecutionMemory</code>ä¸­ä¸»è¦çš„ä»»åŠ¡å°±æ˜¯è¦ç»™å‡º<code>MemoryPool.acquireMemory()</code>ä¸­çš„ä¸¤ä¸ªå›è°ƒï¼Œä¸€ä¸ªæ˜¯è·å–æ›´å¤šçš„ExecutionåŒºå†…å­˜çš„å›è°ƒï¼Œä¸€ä¸ªæ˜¯è·å–ExecutionåŒºæœ€å¤šèƒ½è·å–åˆ°çš„å†…å­˜å¤§å°ã€‚</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybeGrowExecutionPool</span></span>(extraMemoryNeeded: <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (extraMemoryNeeded &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There is not enough free memory in the execution pool, so try to reclaim memory from</span></span><br><span class="line">    <span class="comment">// storage. We can reclaim any free memory from the storage pool. If the storage pool</span></span><br><span class="line">    <span class="comment">// has grown to become larger than `storageRegionSize`, we can evict blocks and reclaim</span></span><br><span class="line">    <span class="comment">// the memory that storage has borrowed from execution.</span></span><br><span class="line">    <span class="keyword">val</span> memoryReclaimableFromStorage = math.max(</span><br><span class="line">      storagePool.memoryFree,</span><br><span class="line">      storagePool.poolSize - storageRegionSize)</span><br><span class="line">    <span class="keyword">if</span> (memoryReclaimableFromStorage &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Only reclaim as much space as is necessary and available:</span></span><br><span class="line">      <span class="keyword">val</span> spaceToReclaim = storagePool.freeSpaceToShrinkPool(</span><br><span class="line">        math.min(extraMemoryNeeded, memoryReclaimableFromStorage))</span><br><span class="line">      storagePool.decrementPoolSize(spaceToReclaim)</span><br><span class="line">      executionPool.incrementPoolSize(spaceToReclaim)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ğŸ‘†è·å–æ›´å¤šçš„ExecutionåŒºå†…å­˜çš„å›è°ƒï¼Œè¿™é‡Œæœ€é‡è¦çš„æ˜¯è®¡ç®—å¯ä»¥å½’è¿˜å†…å­˜å¤§å°çš„é€»è¾‘ï¼Œåœ¨<code>memoryFree</code>ï¼ˆç©ºé—²çš„å†…å­˜å¤§å°ï¼‰å’Œ<code>poolSize-storageRegionSize</code>ï¼ˆå‘ExecutionsåŒºå€Ÿçš„å†…å­˜å¤§å°ï¼‰ä¸­å–ä¸€ä¸ªæ›´å¤§çš„å€¼ã€‚ç„¶åçœŸæ­£å½’è¿˜çš„å†…å­˜å¤§å°æ˜¯åœ¨<code>memoryReclaimableFromStorage</code>ï¼ˆå¯ä»¥å½’è¿˜çš„å†…å­˜å¤§å°ï¼‰å’Œ<code>extraMemoryNeeded</code>ï¼ˆExecutionsåŒºéœ€è¦æ‰©å¤§çš„å†…å­˜å¤§å°ï¼‰ä¹‹é—´å–ä¸€ä¸ªæ›´å°çš„å€¼ã€‚</p>
<p>è®¡ç®—å®Œæˆä»¥åéœ€è¦çœŸæ­£çš„è¿›è¡Œå†…å­˜æ“ä½œé‡Šæ”¾éœ€è¦çš„å†…å­˜ï¼Œè¯¥æ–¹æ³•åœ¨<code>StorageMemoryPool</code>ä¸­ï¼š</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeSpaceToShrinkPool</span></span>(spaceToFree: <span class="type">Long</span>): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> spaceFreedByReleasingUnusedMemory = math.min(spaceToFree, memoryFree)</span><br><span class="line">  <span class="keyword">val</span> remainingSpaceToFree = spaceToFree - spaceFreedByReleasingUnusedMemory</span><br><span class="line">  <span class="keyword">if</span> (remainingSpaceToFree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// If reclaiming free memory did not adequately shrink the pool, begin evicting blocks:</span></span><br><span class="line">    <span class="keyword">val</span> spaceFreedByEviction =</span><br><span class="line">      memoryStore.evictBlocksToFreeSpace(<span class="type">None</span>, remainingSpaceToFree, memoryMode)</span><br><span class="line">    <span class="comment">// When a block is released, BlockManager.dropFromMemory() calls releaseMemory(), so we do</span></span><br><span class="line">    <span class="comment">// not need to decrement _memoryUsed here. However, we do need to decrement the pool size.</span></span><br><span class="line">    spaceFreedByReleasingUnusedMemory + spaceFreedByEviction</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    spaceFreedByReleasingUnusedMemory</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>å…ˆè®¡ç®—ç©ºé—²ç©ºé—´çš„å¤§å°ï¼Œå¦‚æœç©ºé—²ç©ºé—´å¤§äºç­‰äºéœ€è¦é‡Šæ”¾çš„ç©ºé—´å¤§å°ï¼Œåˆ™ä¸éœ€è¦è¿›è¡Œå†…å­˜å¯¹è±¡æ“ä½œã€‚å¦åˆ™çš„è¯ï¼Œéœ€è¦åˆ é™¤ä¸€äº›å†…å­˜Blockã€‚åˆ é™¤çš„æ–¹æ³•åœ¨<code>MemoryStore</code>ä¸­ï¼š</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">evictBlocksToFreeSpace</span></span>(</span><br><span class="line">    blockId: <span class="type">Option</span>[<span class="type">BlockId</span>],</span><br><span class="line">    space: <span class="type">Long</span>,</span><br><span class="line">    memoryMode: <span class="type">MemoryMode</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">  assert(space &gt; <span class="number">0</span>)</span><br><span class="line">  memoryManager.synchronized &#123;</span><br><span class="line">    <span class="keyword">var</span> freedMemory = <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">val</span> rddToAdd = blockId.flatMap(getRddId)</span><br><span class="line">    <span class="keyword">val</span> selectedBlocks = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">BlockId</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blockIsEvictable</span></span>(blockId: <span class="type">BlockId</span>, entry: <span class="type">MemoryEntry</span>[_]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">      entry.memoryMode == memoryMode &amp;&amp; (rddToAdd.isEmpty || rddToAdd != getRddId(blockId))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is synchronized to ensure that the set of entries is not changed</span></span><br><span class="line">    <span class="comment">// (because of getValue or getBytes) while traversing the iterator, as that</span></span><br><span class="line">    <span class="comment">// can lead to exceptions.</span></span><br><span class="line">    entries.synchronized &#123;</span><br><span class="line">      <span class="keyword">val</span> iterator = entries.entrySet().iterator()</span><br><span class="line">      <span class="keyword">while</span> (freedMemory &lt; space &amp;&amp; iterator.hasNext) &#123;</span><br><span class="line">        <span class="keyword">val</span> pair = iterator.next()</span><br><span class="line">        <span class="keyword">val</span> blockId = pair.getKey</span><br><span class="line">        <span class="keyword">val</span> entry = pair.getValue</span><br><span class="line">        <span class="keyword">if</span> (blockIsEvictable(blockId, entry)) &#123;</span><br><span class="line">          <span class="comment">// We don't want to evict blocks which are currently being read, so we need to obtain</span></span><br><span class="line">          <span class="comment">// an exclusive write lock on blocks which are candidates for eviction. We perform a</span></span><br><span class="line">          <span class="comment">// non-blocking "tryLock" here in order to ignore blocks which are locked for reading:</span></span><br><span class="line">          <span class="keyword">if</span> (blockInfoManager.lockForWriting(blockId, blocking = <span class="literal">false</span>).isDefined) &#123;</span><br><span class="line">            selectedBlocks += blockId</span><br><span class="line">            freedMemory += pair.getValue.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dropBlock</span></span>[<span class="type">T</span>](blockId: <span class="type">BlockId</span>, entry: <span class="type">MemoryEntry</span>[<span class="type">T</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> data = entry <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">DeserializedMemoryEntry</span>(values, _, _) =&gt; <span class="type">Left</span>(values)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SerializedMemoryEntry</span>(buffer, _, _) =&gt; <span class="type">Right</span>(buffer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> newEffectiveStorageLevel =</span><br><span class="line">        blockEvictionHandler.dropFromMemory(blockId, () =&gt; data)(entry.classTag)</span><br><span class="line">      <span class="keyword">if</span> (newEffectiveStorageLevel.isValid) &#123;</span><br><span class="line">        <span class="comment">// The block is still present in at least one store, so release the lock</span></span><br><span class="line">        <span class="comment">// but don't delete the block info</span></span><br><span class="line">        blockInfoManager.unlock(blockId)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The block isn't present in any store, so delete the block info so that the</span></span><br><span class="line">        <span class="comment">// block can be stored again</span></span><br><span class="line">        blockInfoManager.removeBlock(blockId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freedMemory &gt;= space) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastSuccessfulBlock = <span class="number">-1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        logInfo(<span class="string">s"<span class="subst">$&#123;selectedBlocks.size&#125;</span> blocks selected for dropping "</span> +</span><br><span class="line">          <span class="string">s"(<span class="subst">$&#123;Utils.bytesToString(freedMemory)&#125;</span> bytes)"</span>)</span><br><span class="line">        (<span class="number">0</span> until selectedBlocks.size).foreach &#123; idx =&gt;</span><br><span class="line">          <span class="keyword">val</span> blockId = selectedBlocks(idx)</span><br><span class="line">          <span class="keyword">val</span> entry = entries.synchronized &#123;</span><br><span class="line">            entries.get(blockId)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// This should never be null as only one task should be dropping</span></span><br><span class="line">          <span class="comment">// blocks and removing entries. However the check is still here for</span></span><br><span class="line">          <span class="comment">// future safety.</span></span><br><span class="line">          <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">            dropBlock(blockId, entry)</span><br><span class="line">            afterDropAction(blockId)</span><br><span class="line">          &#125;</span><br><span class="line">          lastSuccessfulBlock = idx</span><br><span class="line">        &#125;</span><br><span class="line">        logInfo(<span class="string">s"After dropping <span class="subst">$&#123;selectedBlocks.size&#125;</span> blocks, "</span> +</span><br><span class="line">          <span class="string">s"free memory is <span class="subst">$&#123;Utils.bytesToString(maxMemory - blocksMemoryUsed)&#125;</span>"</span>)</span><br><span class="line">        freedMemory</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// like BlockManager.doPut, we use a finally rather than a catch to avoid having to deal</span></span><br><span class="line">        <span class="comment">// with InterruptedException</span></span><br><span class="line">        <span class="keyword">if</span> (lastSuccessfulBlock != selectedBlocks.size - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// the blocks we didn't process successfully are still locked, so we have to unlock them</span></span><br><span class="line">          (lastSuccessfulBlock + <span class="number">1</span> until selectedBlocks.size).foreach &#123; idx =&gt;</span><br><span class="line">            <span class="keyword">val</span> blockId = selectedBlocks(idx)</span><br><span class="line">            blockInfoManager.unlock(blockId)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      blockId.foreach &#123; id =&gt;</span><br><span class="line">        logInfo(<span class="string">s"Will not store <span class="subst">$id</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      selectedBlocks.foreach &#123; id =&gt;</span><br><span class="line">        blockInfoManager.unlock(id)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¯¥ç±»å½“ä¸­æœ‰ä¸€ä¸ªå­˜å‚¨æ‰€æœ‰Blockçš„Mapï¼Œå³ï¼š</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> entries = <span class="keyword">new</span> <span class="type">LinkedHashMap</span>[<span class="type">BlockId</span>, <span class="type">MemoryEntry</span>[_]](<span class="number">32</span>, <span class="number">0.75</span>f, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ‰€ä»¥æ¯æ¬¡æ“ä½œä¹‹å‰ä¹Ÿæ˜¯éœ€è¦åŠ é”ã€‚å¦‚æœæ²¡æœ‰è·å–åˆ°éœ€è¦é‡Šæ”¾çš„å†…å­˜ç©ºé—´å¤§å°åˆ™éå†Blockï¼Œåˆ¤æ–­éå†çš„Blockä¸éœ€è¦å­˜å‚¨çš„Blockæ˜¯å¦æ˜¯åŒä¸€ä¸ªå­˜å‚¨åŒºåŸŸï¼ˆè¿˜åˆ¤æ–­äº†éå†çš„Blockä¸éœ€è¦å­˜å‚¨çš„Blockæ˜¯å¦æ˜¯åŒä¸€ä¸ªï¼‰ï¼Œå¦‚æœé€šè¿‡äº†åˆ¤æ–­åˆ™éœ€è¦å…ˆå°†è¯¥Blocké”ä½ï¼ŒåŠ å…¥å€™é€‰åå•ã€‚</p>
<p>æ‰¾å¤Ÿæ‰€æœ‰çš„å€™é€‰è€…ä»¥åè¿˜æ²¡æœ‰è¾¾åˆ°éœ€è¦é‡Šæ”¾çš„å†…å­˜ç©ºé—´å¤§å°åˆ™å°†æ‰€æœ‰é”ä½çš„Blockè§£é”ï¼Œè¿”å›0ï¼Œè¡¨ç¤ºè¿™ä¸ªæ“ä½œå¤±è´¥ã€‚å¦‚æœè¾¾åˆ°äº†ï¼Œåˆ™å¼€å§‹é‡Šæ”¾å†…å­˜çš„è¿‡ç¨‹ã€‚å°†æ¯ä¸€ä¸ªBlockæ‰§è¡Œ<code>dropBlock</code>ï¼Œ<code>afterDropAction</code>çš„æ“ä½œã€‚åœ¨<code>dropBlock</code>ä¸­ä¼šåˆ é™¤è¯¥Blockæœ¬èº«çš„æ•°æ®ï¼ˆé™¤éBlockè¿˜åœ¨è¢«æ“ä½œï¼‰ï¼Œæ£€æŸ¥Blockæ˜¯å¦è¿˜åœ¨è¢«å…¶ä»–çš„storageå­˜å‚¨ï¼Œå¦‚æœæ˜¯çš„è¯å°±å…ˆä¸åˆ é™¤å…¶metadataï¼Œå¦åˆ™çš„è¯ç»§ç»­åˆ é™¤metadataã€‚<code>afterDropAction</code>æ˜¯ä¸ªhookï¼Œå¯ä»¥ç”±è°ƒç”¨æ–¹æŒ‡å®šåˆ é™¤ä¹‹åçš„åŠ¨ä½œã€‚å¦‚æœåœ¨åˆ é™¤è¿‡ç¨‹å½“ä¸­å¤±è´¥çš„è¯ï¼Œéœ€è¦å°†æ²¡æœ‰åˆ é™¤çš„Blockè§£é”ã€‚</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeMaxExecutionPoolSize</span></span>(): <span class="type">Long</span> = &#123;</span><br><span class="line">  maxMemory - math.min(storagePool.memoryUsed, storageRegionSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ğŸ‘†è·å–ExecutionåŒºæœ€å¤šèƒ½è·å–åˆ°çš„å†…å­˜å¤§å°ï¼Œæ˜¯é€šè¿‡æœ€å¤§çš„å†…å­˜å¤§å°å‡å»StorageåŒºæœ€å¤§èƒ½å ç”¨çš„å†…å­˜å¤§å°ã€‚StorageåŒºèƒ½å ç”¨çš„ä¸Šé™æ˜¯<code>storageRegionSize</code>ã€‚</p>
<p>ä¸‹é¢æ¥çœ‹çœŸæ­£è¿›è¡Œå†…å­˜åˆ†é…çš„å‡½æ•°<code>acquireMemory</code>ï¼Œè¯¥æ–¹æ³•åœ¨<code>ExecutionMemoryPool</code>ä¸­ï¼š</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[memory] <span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(</span><br><span class="line">    numBytes: <span class="type">Long</span>,</span><br><span class="line">    taskAttemptId: <span class="type">Long</span>,</span><br><span class="line">    maybeGrowPool: <span class="type">Long</span> =&gt; <span class="type">Unit</span> = (additionalSpaceNeeded: <span class="type">Long</span>) =&gt; (),</span><br><span class="line">    computeMaxPoolSize: () =&gt; <span class="type">Long</span> = () =&gt; poolSize): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  assert(numBytes &gt; <span class="number">0</span>, <span class="string">s"invalid number of bytes requested: <span class="subst">$numBytes</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> clean up this clunky method signature</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add this task to the taskMemory map just so we can keep an accurate count of the number</span></span><br><span class="line">  <span class="comment">// of active tasks, to let other tasks ramp down their memory in calls to `acquireMemory`</span></span><br><span class="line">  <span class="keyword">if</span> (!memoryForTask.contains(taskAttemptId)) &#123;</span><br><span class="line">    memoryForTask(taskAttemptId) = <span class="number">0</span>L</span><br><span class="line">    <span class="comment">// This will later cause waiting tasks to wake up and check numTasks again</span></span><br><span class="line">    lock.notifyAll()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep looping until we're either sure that we don't want to grant this request (because this</span></span><br><span class="line">  <span class="comment">// task would have more than 1 / numActiveTasks of the memory) or we have enough free</span></span><br><span class="line">  <span class="comment">// memory to give it (we always let each task get at least 1 / (2 * numActiveTasks)).</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> simplify this to limit each task to its own slot</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> numActiveTasks = memoryForTask.keys.size</span><br><span class="line">    <span class="keyword">val</span> curMem = memoryForTask(taskAttemptId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In every iteration of this loop, we should first try to reclaim any borrowed execution</span></span><br><span class="line">    <span class="comment">// space from storage. This is necessary because of the potential race condition where new</span></span><br><span class="line">    <span class="comment">// storage blocks may steal the free execution memory that this task was waiting for.</span></span><br><span class="line">    maybeGrowPool(numBytes - memoryFree)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maximum size the pool would have after potentially growing the pool.</span></span><br><span class="line">    <span class="comment">// This is used to compute the upper bound of how much memory each task can occupy. This</span></span><br><span class="line">    <span class="comment">// must take into account potential free memory as well as the amount this pool currently</span></span><br><span class="line">    <span class="comment">// occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,</span></span><br><span class="line">    <span class="comment">// we did not take into account space that could have been freed by evicting cached blocks.</span></span><br><span class="line">    <span class="keyword">val</span> maxPoolSize = computeMaxPoolSize()</span><br><span class="line">    <span class="keyword">val</span> maxMemoryPerTask = maxPoolSize / numActiveTasks</span><br><span class="line">    <span class="keyword">val</span> minMemoryPerTask = poolSize / (<span class="number">2</span> * numActiveTasks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// How much we can grant this task; keep its share within 0 &lt;= X &lt;= 1 / numActiveTasks</span></span><br><span class="line">    <span class="keyword">val</span> maxToGrant = math.min(numBytes, math.max(<span class="number">0</span>, maxMemoryPerTask - curMem))</span><br><span class="line">    <span class="comment">// Only give it as much memory as is free, which might be none if it reached 1 / numTasks</span></span><br><span class="line">    <span class="keyword">val</span> toGrant = math.min(maxToGrant, memoryFree)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to let each task get at least 1 / (2 * numActiveTasks) before blocking;</span></span><br><span class="line">    <span class="comment">// if we can't give it this much now, wait for other tasks to free up memory</span></span><br><span class="line">    <span class="comment">// (this happens if older tasks allocated lots of memory before N grew)</span></span><br><span class="line">    <span class="keyword">if</span> (toGrant &lt; numBytes &amp;&amp; curMem + toGrant &lt; minMemoryPerTask) &#123;</span><br><span class="line">      logInfo(<span class="string">s"TID <span class="subst">$taskAttemptId</span> waiting for at least 1/2N of <span class="subst">$poolName</span> pool to be free"</span>)</span><br><span class="line">      lock.wait()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memoryForTask(taskAttemptId) += toGrant</span><br><span class="line">      <span class="keyword">return</span> toGrant</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">0</span>L  <span class="comment">// Never reached</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>é¦–å…ˆå…³æ³¨ä¸€ä¸‹é”çš„å¯¹è±¡ï¼Œåœ¨è°ƒç”¨æ–¹<code>MemoryManager</code>åˆå§‹åŒ–çš„æ—¶å€™æœ‰å£°æ˜é”çš„å¯¹è±¡ï¼š</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> onHeapStorageMemoryPool = <span class="keyword">new</span> <span class="type">StorageMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span>)</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> offHeapStorageMemoryPool = <span class="keyword">new</span> <span class="type">StorageMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span>)</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> onHeapExecutionMemoryPool = <span class="keyword">new</span> <span class="type">ExecutionMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span>)</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> offHeapExecutionMemoryPool = <span class="keyword">new</span> <span class="type">ExecutionMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[memory] <span class="class"><span class="keyword">class</span> <span class="title">ExecutionMemoryPool</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    lock: <span class="type">Object</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    memoryMode: <span class="type">MemoryMode</span></span></span></span><br><span class="line"><span class="class"><span class="params">  </span>)</span></span><br></pre></td></tr></table></figure>

<p>é€šè¿‡ä¸Šé¢ä¸¤ä¸ªä»£ç ç‰‡æ®µå¯ä»¥çœ‹å‡ºï¼Œå¤šä¸ªPoolçš„é”å¯¹è±¡éƒ½æ˜¯<code>MemoryManger</code>ï¼Œæ‰€ä»¥å¤šä¸ªPoolä¹‹é—´æ˜¯äº’æ–¥çš„ï¼Œä¸è®ºæ˜¯<code>StorageMemoryPool</code>è¿˜æ˜¯<code>ExecutionMemoryPool</code>ã€‚</p>
<p>ç„¶åæ•´ä¸ªå‡½æ•°çš„å·¥ä½œæ–¹å¼ï¼š</p>
<ul>
<li>å¦‚æœæ˜¯ä¸€ä¸ªæ–°çš„taskï¼Œå…ˆå¸®å®ƒåŠ å…¥åˆ°<code>memoryForTask</code>ä¸­ï¼Œå†…å­˜è®¾ä¸º0ï¼Œç„¶åå”¤é†’æ‰€æœ‰ç­‰å¾…é˜Ÿåˆ—é‡Œçš„çº¿ç¨‹å¼€å§‹ç­‰é”ã€‚<code>memoryForTask</code>æ˜¯ä¸€ä¸ªä¿å­˜<code>taskId -&gt; memory</code>çš„mapã€‚</li>
<li>è¿›å…¥ä¸€ä¸ªæ­»å¾ªç¯ä¸­ï¼Œå…ˆæŸ¥çœ‹æ˜¯å¦éœ€è¦è·å–æ›´å¤šçš„å†…å­˜ï¼Œå¦‚æœéœ€è¦çš„è¯åˆ™è°ƒç”¨<code>maybeGrowPool</code>å›è°ƒã€‚è®¡ç®—ä¸€ä¸ªtaskç†è®ºèƒ½åˆ†é…åˆ°çš„æœ€å¤§å†…å­˜å’Œæœ€å°å†…å­˜ï¼Œå³<code>1/2N * maxPoolSize &lt;= cache &lt;= 1/N * maxPoolSize</code>ã€‚æ¥ç€è®¡ç®—å®é™…æœ€å¤§èƒ½åˆ†é…åˆ°çš„å†…å­˜ä»¥åŠæœ€ç»ˆå®é™…åˆ†é…çš„å†…å­˜ã€‚</li>
<li>å¦‚æœå®é™…åˆ†é…åˆ°çš„å†…å­˜å°äºéœ€è¦çš„å†…å­˜æˆ–è€…è¿™ä¸ªä»»åŠ¡åˆ†é…åˆ°çš„æ€»å†…å­˜éƒ½æ²¡æœ‰è¾¾åˆ°ç†è®ºæœ€å°å†…å­˜çš„è¯ï¼Œåˆ™å°†é”è¿˜æ‰ä»¥åç»§ç»­ç­‰é”ã€‚å¦‚æœæ‹¿åˆ°äº†éœ€è¦çš„å†…å­˜ä»¥åå°±æ›´æ–°<code>memoryForTask</code>å¹¶è¿›è¡Œè¿”å›ã€‚</li>
</ul>
<p>::acquireStorageMemory::</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">acquireStorageMemory</span></span>(</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    numBytes: <span class="type">Long</span>,</span><br><span class="line">    memoryMode: <span class="type">MemoryMode</span>): <span class="type">Boolean</span> = synchronized &#123;</span><br><span class="line">  assertInvariants()</span><br><span class="line">  assert(numBytes &gt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> (executionPool, storagePool, maxMemory) = memoryMode <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span> =&gt; (</span><br><span class="line">      onHeapExecutionMemoryPool,</span><br><span class="line">      onHeapStorageMemoryPool,</span><br><span class="line">      maxOnHeapStorageMemory)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span> =&gt; (</span><br><span class="line">      offHeapExecutionMemoryPool,</span><br><span class="line">      offHeapStorageMemoryPool,</span><br><span class="line">      maxOffHeapStorageMemory)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numBytes &gt; maxMemory) &#123;</span><br><span class="line">    <span class="comment">// Fail fast if the block simply won't fit</span></span><br><span class="line">    logInfo(<span class="string">s"Will not store <span class="subst">$blockId</span> as the required space (<span class="subst">$numBytes</span> bytes) exceeds our "</span> +</span><br><span class="line">      <span class="string">s"memory limit (<span class="subst">$maxMemory</span> bytes)"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numBytes &gt; storagePool.memoryFree) &#123;</span><br><span class="line">    <span class="comment">// There is not enough free memory in the storage pool, so try to borrow free memory from</span></span><br><span class="line">    <span class="comment">// the execution pool.</span></span><br><span class="line">    <span class="keyword">val</span> memoryBorrowedFromExecution = <span class="type">Math</span>.min(executionPool.memoryFree,</span><br><span class="line">      numBytes - storagePool.memoryFree)</span><br><span class="line">    executionPool.decrementPoolSize(memoryBorrowedFromExecution)</span><br><span class="line">    storagePool.incrementPoolSize(memoryBorrowedFromExecution)</span><br><span class="line">  &#125;</span><br><span class="line">  storagePool.acquireMemory(blockId, numBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å¦‚æœéœ€è¦ç”³è¯·çš„å†…å­˜å¤§äºæœ€å¤§å†…å­˜åˆ™è¿”å›falseï¼Œç”³è¯·çš„å†…å­˜å¤§äºStorageåŒºçš„å‰©ä½™å†…å­˜ï¼Œåˆ™éœ€è¦ä»ExecutionåŒºå€Ÿå†…å­˜ã€‚StorageåŒºä¸èƒ½å°†æ­£åœ¨è¿è¡Œçš„taskè¸¢å‡ºExecutionåŒºï¼Œæ‰€ä»¥åªèƒ½ä»ä¸­è·å–ç©ºé—²çš„ç©ºé—´å¤§å°ã€‚æ•°å€¼è®¡ç®—å®Œæˆä»¥åï¼Œå¼€å§‹çœŸæ­£çš„åˆ†é…ã€‚</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    numBytesToAcquire: <span class="type">Long</span>,</span><br><span class="line">    numBytesToFree: <span class="type">Long</span>): <span class="type">Boolean</span> = lock.synchronized &#123;</span><br><span class="line">  assert(numBytesToAcquire &gt;= <span class="number">0</span>)</span><br><span class="line">  assert(numBytesToFree &gt;= <span class="number">0</span>)</span><br><span class="line">  assert(memoryUsed &lt;= poolSize)</span><br><span class="line">  <span class="keyword">if</span> (numBytesToFree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    memoryStore.evictBlocksToFreeSpace(<span class="type">Some</span>(blockId), numBytesToFree, memoryMode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> If the memory store evicts blocks, then those evictions will synchronously call</span></span><br><span class="line">  <span class="comment">// back into this StorageMemoryPool in order to free memory. Therefore, these variables</span></span><br><span class="line">  <span class="comment">// should have been updated.</span></span><br><span class="line">  <span class="keyword">val</span> enoughMemory = numBytesToAcquire &lt;= memoryFree</span><br><span class="line">  <span class="keyword">if</span> (enoughMemory) &#123;</span><br><span class="line">    _memoryUsed += numBytesToAcquire</span><br><span class="line">  &#125;</span><br><span class="line">  enoughMemory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å…ˆä»Storageä¸­åˆ é™¤ä¸€äº›Blocké‡Šæ”¾ä¸€äº›å†…å­˜ï¼Œå¦‚æœæœ‰è¶³å¤Ÿçš„å†…å­˜ç”³è¯·å°±æ›´æ–°å·²ä½¿ç”¨çš„å†…å­˜è®¡æ•°å™¨ï¼Œå¦åˆ™ç›´æ¥è¿”å›falseã€‚</p>
<h3 id="MemoryPool"><a href="#MemoryPool" class="headerlink" title="MemoryPool"></a>MemoryPool</h3><p>è¿™æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œæ•´ä¸ªç±»éƒ½åœ¨ç»´æŠ¤ä¸€ä¸ªå˜é‡<code>_poolSize</code>ï¼Œè¡¨ç¤ºå†…å­˜ä½¿ç”¨é‡ã€‚æä¾›äº†ç»´æŠ¤è¿™ä¸ªé‡çš„ä¸€äº›æ–¹æ³•ï¼Œå¦‚ï¼š</p>
<ul>
<li><code>poolSize: Long</code>ï¼šè·å–<code>_poolSize</code></li>
<li><code>memoryFree: Long</code>ï¼šè·å–ç©ºé—²çš„å†…å­˜ç©ºé—´å¤§å°</li>
<li><code>incrementPoolSize(delta: Long)</code>ï¼šæé«˜<code>_poolSize</code></li>
<li><code>decrementPoolSize(delta: Long)</code>ï¼šé™ä½<code>_poolSize</code></li>
</ul>
<p>ä»¥åŠä¸€ä¸ªæŠ½è±¡æ–¹æ³•ï¼š</p>
<ul>
<li><code>memoryUsed: Long</code></li>
</ul>
<h3 id="ExecutionMemoryPool"><a href="#ExecutionMemoryPool" class="headerlink" title="ExecutionMemoryPool"></a>ExecutionMemoryPool</h3><p>è¯¥ç±»ä¸­ç»´æŠ¤äº†ä¸€ä¸ª<code>taskId -&gt; memory</code>çš„Mapï¼š<code>memoryForTask</code>æ¥ç®¡ç†å†…å­˜ã€‚</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">memoryUsed</span></span>: <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  memoryForTask.values.sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å®ç°çˆ¶ç±»çš„æŠ½è±¡æ–¹æ³•ï¼Œç›´æ¥å°†<code>memoryForTask</code>ä¸­çš„valuesç´¯åŠ ã€‚</p>
<p><code>acquireMemory</code>å·²ç»åœ¨ä¸Šæ–‡ä¸­åˆ†æè¿‡äº†ã€‚<code>releaseMemory</code>åœ¨<code>MemoryManager.releaseExecutionMemory</code>ä¸­è¢«è°ƒç”¨ï¼š</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseMemory</span></span>(numBytes: <span class="type">Long</span>, taskAttemptId: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> curMem = memoryForTask.getOrElse(taskAttemptId, <span class="number">0</span>L)</span><br><span class="line">  <span class="keyword">val</span> memoryToFree = <span class="keyword">if</span> (curMem &lt; numBytes) &#123;</span><br><span class="line">    logWarning(</span><br><span class="line">      <span class="string">s"Internal error: release called on <span class="subst">$numBytes</span> bytes but task only has <span class="subst">$curMem</span> bytes "</span> +</span><br><span class="line">        <span class="string">s"of memory from the <span class="subst">$poolName</span> pool"</span>)</span><br><span class="line">    curMem</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    numBytes</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (memoryForTask.contains(taskAttemptId)) &#123;</span><br><span class="line">    memoryForTask(taskAttemptId) -= memoryToFree</span><br><span class="line">    <span class="keyword">if</span> (memoryForTask(taskAttemptId) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      memoryForTask.remove(taskAttemptId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lock.notifyAll() <span class="comment">// Notify waiters in acquireMemory() that memory has been freed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>åœ¨æ­£å¼é‡Šæ”¾ä¹‹å‰ä¼šå…ˆæ¯”è¾ƒä¸€ä¸‹ç°åœ¨è¯¥taskæ‰€å ç”¨çš„å†…å­˜å’Œéœ€è¦é‡Šæ”¾çš„å†…å­˜çš„å¤§å°ï¼Œå¦‚æœtaskæ‰€å å†…å­˜å°äºéœ€è¦é‡Šæ”¾çš„å†…å­˜ä¹Ÿåªä¼šé‡Šæ”¾taskæ‰€å å†…å­˜ï¼Œä¸ä¼šå†é‡Šæ”¾å…¶ä»–çš„taskã€‚å› ä¸ºæœ‰æ–°çš„å†…å­˜ç©ºé—´å‡ºç°ï¼Œæ‰€ä»¥å¯ä»¥å”¤é†’ç­‰å¾…é˜Ÿåˆ—é‡Œçš„çº¿ç¨‹ï¼Œå¼€å§‹ç»™æ–°ä»»åŠ¡äº‰å–å†…å­˜ã€‚</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseAllMemoryForTask</span></span>(taskAttemptId: <span class="type">Long</span>): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> numBytesToFree = getMemoryUsageForTask(taskAttemptId)</span><br><span class="line">  releaseMemory(numBytesToFree, taskAttemptId)</span><br><span class="line">  numBytesToFree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¯¥æ–¹æ³•ä¼šé‡Šæ”¾ä¸€ä¸ªtaskæ‰€æœ‰çš„å†…å­˜ï¼Œç›´æ¥è·å–taskæ‰€å ç”¨çš„å†…å­˜ä»¥åè°ƒç”¨ä¸Šé¢çš„<code>releaseMemory</code>æ–¹æ³•ã€‚</p>
<h3 id="StorageMemoryPool"><a href="#StorageMemoryPool" class="headerlink" title="StorageMemoryPool"></a>StorageMemoryPool</h3><p>è¯¥ç±»è´Ÿè´£StorageåŒºçš„å†…å­˜ç®¡ç†ï¼Œåœ¨ç±»ä¸­ç»´æŠ¤äº†ä¸€ä¸ª<code>_memoryUsed</code>å‚æ•°ï¼Œæ¥è¡¨ç¤ºä½¿ç”¨äº†å¤šå°‘å†…å­˜ã€‚å¹¶ä¸”ä¼šå…³è”ä¸€ä¸ª<code>MemoryStore</code>å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ä¼šå®ŒæˆçœŸæ­£çš„å†…å­˜ç®¡ç†æ“ä½œã€‚</p>
<p>é‡è¦çš„<code>acquireMemory</code>å’Œ<code>freeSpaceToShrinkPool</code>å‡½æ•°å‡åœ¨ä¸Šæ–‡ä¸­è¿›è¡Œäº†ä»‹ç»ã€‚</p>
<h3 id="TaskMemoryManager"><a href="#TaskMemoryManager" class="headerlink" title="TaskMemoryManager"></a>TaskMemoryManager</h3><p>è¯¥ç±»è´Ÿè´£ç®¡ç†ä¸€ä¸ªtaskçš„å†…å­˜ï¼Œè¯¥ç±»ä¸­ä¸ä¼šç›´æ¥æ“ä½œå†…å­˜ï¼Œä¼šé€šè¿‡<code>MemoryManager</code>æ¥è¿›è¡Œç®¡ç†ã€‚ä¸è¿‡å› ä¸ºåº•å±‚ä½¿ç”¨äº†<code>Tungsten</code>å†…å­˜æ¨¡å‹ï¼Œè¯¥ç±»ä¸­è¿˜ä¼šç»´æŠ¤å†…å­˜æ¨¡å‹ä½¿ç”¨çš„é¡µæœºåˆ¶ç›¸å…³çš„å˜é‡ã€‚æ‰€æœ‰çš„<code>TaskMemoryManager</code>ä¼šå…±ç”¨ä¸€ä¸ª<code>MemoryManager</code>ã€‚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">acquireExecutionMemory</span><span class="params">(<span class="keyword">long</span> required, MemoryConsumer consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span>(required &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">assert</span>(consumer != <span class="keyword">null</span>);</span><br><span class="line">  MemoryMode mode = consumer.getMode();</span><br><span class="line">  <span class="comment">// If we are allocating Tungsten pages off-heap and receive a request to allocate on-heap</span></span><br><span class="line">  <span class="comment">// memory here, then it may not make sense to spill since that would only end up freeing</span></span><br><span class="line">  <span class="comment">// off-heap memory. This is subject to change, though, so it may be risky to make this</span></span><br><span class="line">  <span class="comment">// optimization now in case we forget to undo it late when making changes.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> got = memoryManager.acquireExecutionMemory(required, taskAttemptId, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to release memory from other consumers first, then we can reduce the frequency of</span></span><br><span class="line">    <span class="comment">// spilling, avoid to have too many spilled files.</span></span><br><span class="line">    <span class="keyword">if</span> (got &lt; required) &#123;</span><br><span class="line">      <span class="comment">// Call spill() on other consumers to release memory</span></span><br><span class="line">      <span class="comment">// Sort the consumers according their memory usage. So we avoid spilling the same consumer</span></span><br><span class="line">      <span class="comment">// which is just spilled in last few times and re-spilling on it will produce many small</span></span><br><span class="line">      <span class="comment">// spill files.</span></span><br><span class="line">      TreeMap&lt;Long, List&lt;MemoryConsumer&gt;&gt; sortedConsumers = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MemoryConsumer c: consumers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != consumer &amp;&amp; c.getUsed() &gt; <span class="number">0</span> &amp;&amp; c.getMode() == mode) &#123;</span><br><span class="line">          <span class="keyword">long</span> key = c.getUsed();</span><br><span class="line">          List&lt;MemoryConsumer&gt; list =</span><br><span class="line">              sortedConsumers.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>));</span><br><span class="line">          list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!sortedConsumers.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// Get the consumer using the least memory more than the remaining required memory.</span></span><br><span class="line">        Map.Entry&lt;Long, List&lt;MemoryConsumer&gt;&gt; currentEntry =</span><br><span class="line">          sortedConsumers.ceilingEntry(required - got);</span><br><span class="line">        <span class="comment">// No consumer has used memory more than the remaining required memory.</span></span><br><span class="line">        <span class="comment">// Get the consumer of largest used memory.</span></span><br><span class="line">        <span class="keyword">if</span> (currentEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">          currentEntry = sortedConsumers.lastEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;MemoryConsumer&gt; cList = currentEntry.getValue();</span><br><span class="line">        MemoryConsumer c = cList.get(cList.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> released = c.spill(required - got, consumer);</span><br><span class="line">          <span class="keyword">if</span> (released &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Task &#123;&#125; released &#123;&#125; from &#123;&#125; for &#123;&#125;"</span>, taskAttemptId,</span><br><span class="line">              Utils.bytesToString(released), c, consumer);</span><br><span class="line">            got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId, mode);</span><br><span class="line">            <span class="keyword">if</span> (got &gt;= required) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cList.remove(cList.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cList.isEmpty()) &#123;</span><br><span class="line">              sortedConsumers.remove(currentEntry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClosedByInterruptException e) &#123;</span><br><span class="line">          <span class="comment">// This called by user to kill a task (e.g: speculative task).</span></span><br><span class="line">          logger.error(<span class="string">"error while calling spill() on "</span> + c, e);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          logger.error(<span class="string">"error while calling spill() on "</span> + c, e);</span><br><span class="line">          <span class="comment">// checkstyle.off: RegexpSinglelineJava</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SparkOutOfMemoryError(<span class="string">"error while calling spill() on "</span> + c + <span class="string">" : "</span></span><br><span class="line">            + e.getMessage());</span><br><span class="line">          <span class="comment">// checkstyle.on: RegexpSinglelineJava</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call spill() on itself</span></span><br><span class="line">    <span class="keyword">if</span> (got &lt; required) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> released = consumer.spill(required - got, consumer);</span><br><span class="line">        <span class="keyword">if</span> (released &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Task &#123;&#125; released &#123;&#125; from itself (&#123;&#125;)"</span>, taskAttemptId,</span><br><span class="line">            Utils.bytesToString(released), consumer);</span><br><span class="line">          got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId, mode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClosedByInterruptException e) &#123;</span><br><span class="line">        <span class="comment">// This called by user to kill a task (e.g: speculative task).</span></span><br><span class="line">        logger.error(<span class="string">"error while calling spill() on "</span> + consumer, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"error while calling spill() on "</span> + consumer, e);</span><br><span class="line">        <span class="comment">// checkstyle.off: RegexpSinglelineJava</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SparkOutOfMemoryError(<span class="string">"error while calling spill() on "</span> + consumer + <span class="string">" : "</span></span><br><span class="line">          + e.getMessage());</span><br><span class="line">        <span class="comment">// checkstyle.on: RegexpSinglelineJava</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumers.add(consumer);</span><br><span class="line">    logger.debug(<span class="string">"Task &#123;&#125; acquired &#123;&#125; for &#123;&#125;"</span>, taskAttemptId, Utils.bytesToString(got), consumer);</span><br><span class="line">    <span class="keyword">return</span> got;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¯¥æ–¹æ³•æ˜¯ä¸ºä¸€ä¸ªtaskæ–°çš„consumeråˆ†é…å†…å­˜ï¼Œä¸€è¿›æ¥ä¼šå…ˆå°è¯•ä½¿ç”¨ExecutorPoolç”³è¯·<code>required</code>å¤§å°çš„å†…å­˜ï¼Œå¦‚æœèƒ½ç›´æ¥è·å–åˆ°å°±ç»“æŸã€‚å¦åˆ™çš„è¯éœ€è¦ä»consumerä¸­æŒ‘é€‰åˆé€‚çš„consumerè¿›è¡Œspillæ“ä½œï¼ˆä¹Ÿå°±æ˜¯å°†å†…å­˜ä¸­çš„æ•°æ®å†²å†™åˆ°ç¡¬ç›˜ä¸Šï¼‰æ¥é‡Šæ”¾è¶³å¤Ÿå¤šçš„å†…å­˜ã€‚</p>
<p>æŒ‘é€‰çš„è¿‡ç¨‹ä¹Ÿå¾ˆå¸¸è§„ï¼Œä¼šé€‰å‡ºå¤§äºéœ€è¦çš„å†…å­˜çš„consumerä¸­æœ€å°çš„ä¸€ä¸ªï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ä»å¤§åˆ°å°ä¾æ¬¡spillï¼Œç›´åˆ°é‡Šæ”¾çš„å†…å­˜è¾¾åˆ°éœ€æ±‚ã€‚ä¸è¿‡ç­›é€‰å¤§äºéœ€è¦çš„å†…å­˜ä¸­æœ€å°çš„ä¸€ä¸ªç”¨äº†ä¸€ä¸ªå¾ˆç®€æ´å¿«é€Ÿçš„æ–¹å¼ï¼Œåˆ›å»ºäº†ä¸€ä¸ª<code>memory -&gt; List&lt;MemoryConsumer&gt;</code>çš„TreeMapï¼Œç›´æ¥ä½¿ç”¨<code>TreeMap.ceilingEntry</code>æ–¹æ³•ã€‚æ¯æ¬¡é‡Šæ”¾å®Œæˆä»¥åéƒ½å†é‡æ–°ç”³è¯·æ›´å¤šçš„å†…å­˜ï¼Œç›´åˆ°ç”³è¯·åˆ°äº†è¶³å¤Ÿå¤šçš„å†…å­˜ã€‚</p>
<p>å¦‚æœåœ¨ä¸Šé¢çš„æ“ä½œæ‰§è¡Œå®Œæˆä»¥åï¼ˆä¹Ÿå°±æ˜¯èƒ½é‡Šæ”¾çš„éƒ½é‡Šæ”¾æ‰äº†ï¼‰è¿˜æ˜¯ä¸å¤Ÿï¼Œé‚£ä¹ˆå°±å°†è¿™ä¸ªè¦åŠ å…¥çš„æ–°çš„consumerçš„éƒ¨åˆ†æ•°æ®å†²å†™åˆ°ç¡¬ç›˜ä¸Šï¼Œä½¿ä»–èƒ½è¢«æ”¾å…¥MemoryPoolä¸­ã€‚</p>
<h4 id="Allocate-page"><a href="#Allocate-page" class="headerlink" title="Allocate page"></a>Allocate page</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MemoryBlock <span class="title">allocatePage</span><span class="params">(<span class="keyword">long</span> size, MemoryConsumer consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span>(consumer != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(consumer.getMode() == tungstenMemoryMode);</span><br><span class="line">  <span class="keyword">if</span> (size &gt; MAXIMUM_PAGE_SIZE_BYTES) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooLargePageException(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> acquired = acquireExecutionMemory(size, consumer);</span><br><span class="line">  <span class="keyword">if</span> (acquired &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> pageNumber;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    pageNumber = allocatedPages.nextClearBit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pageNumber &gt;= PAGE_TABLE_SIZE) &#123;</span><br><span class="line">      releaseExecutionMemory(acquired, consumer);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Have already allocated a maximum of "</span> + PAGE_TABLE_SIZE + <span class="string">" pages"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedPages.set(pageNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  MemoryBlock page = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    page = memoryManager.tungstenMemoryAllocator().allocate(acquired);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">    logger.warn(<span class="string">"Failed to allocate a page (&#123;&#125; bytes), try again."</span>, acquired);</span><br><span class="line">    <span class="comment">// there is no enough memory actually, it means the actual free memory is smaller than</span></span><br><span class="line">    <span class="comment">// MemoryManager thought, we should keep the acquired memory.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      acquiredButNotUsed += acquired;</span><br><span class="line">      allocatedPages.clear(pageNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this could trigger spilling to free some pages.</span></span><br><span class="line">    <span class="keyword">return</span> allocatePage(size, consumer);</span><br><span class="line">  &#125;</span><br><span class="line">  page.pageNumber = pageNumber;</span><br><span class="line">  pageTable[pageNumber] = page;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Allocate page number &#123;&#125; (&#123;&#125; bytes)"</span>, pageNumber, acquired);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>é¡µç®¡ç†ä¸»è¦ç”±ä¸€ä¸ª <code>BitSet</code>ï¼ˆæ ‡ç¤ºé¡µä½æƒ…å†µï¼‰å’Œ<code>MemoryBlock[]</code>ï¼ˆï¼‰å®ç°ï¼Œtrueè¡¨ç¤ºé¡µä½è¢«å ã€‚è¯¥æ–¹æ³•ä¼šå…ˆè°ƒç”¨<code>acquireExecutionMemory</code>ç”³è¯·å®é™…çš„ç‰©ç†å†…å­˜ï¼Œç„¶åé€šè¿‡<code>BitSet.nextClearBitï¼ˆï¼‰</code>å‡½æ•°è·å–ç¬¬ä¸€ä¸ªç©ºä½ç½®ï¼Œå¹¶è¿›è¡Œå ä½ã€‚å®Œæˆä»¥åå°±ä¼šé€šè¿‡<code>tungstenMemoryAllocator</code>æ¥çœŸæ­£è¿›è¡Œå†…å­˜ç”³è¯·ï¼Œä¸‹é¢ä¼šåˆ†æä¸€ä¸‹on-heapå’Œoff-heapä¸¤ç§ä¸åŒçš„å†…å­˜ç”³è¯·ï¼š</p>
<p>::Unsafe memory allocate::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MemoryBlock <span class="title">allocate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> OutOfMemoryError </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> address = Platform.allocateMemory(size);</span><br><span class="line">  MemoryBlock memory = <span class="keyword">new</span> MemoryBlock(<span class="keyword">null</span>, address, size);</span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_CLEAN_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Off-heapçš„æ‰€æœ‰å†…å­˜æ“ä½œéƒ½æ˜¯é€šè¿‡Unsafeå·¥å…·ç±»æ¥å®Œæˆï¼Œè¿™ä¸ªæ–¹æ³•éå¸¸çš„ç®€å•ã€‚ä¼šå…ˆé€šè¿‡<code>Unsafe.allocateMemory</code>ç”³è¯·å†…å­˜ï¼Œç„¶ååˆå§‹åŒ–ä¸€ä¸ªé¡µç»“æ„ï¼Œoff-heapä¸ä¼šæ˜ å°„å¯¹è±¡ï¼Œæ‰€ä»¥objä¼ å…¥nullå³å¯ã€‚</p>
<p>::Heap memory allocate::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MemoryBlock <span class="title">allocate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> OutOfMemoryError </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numWords = (<span class="keyword">int</span>) ((size + <span class="number">7</span>) / <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">long</span> alignedSize = numWords * <span class="number">8L</span>;</span><br><span class="line">  <span class="keyword">assert</span> (alignedSize &gt;= size);</span><br><span class="line">  <span class="keyword">if</span> (shouldPool(alignedSize)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> LinkedList&lt;WeakReference&lt;<span class="keyword">long</span>[]&gt;&gt; pool = bufferPoolsBySize.get(alignedSize);</span><br><span class="line">      <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!pool.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">final</span> WeakReference&lt;<span class="keyword">long</span>[]&gt; arrayReference = pool.pop();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span>[] array = arrayReference.get();</span><br><span class="line">          <span class="keyword">if</span> (array != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> (array.length * <span class="number">8L</span> &gt;= size);</span><br><span class="line">            MemoryBlock memory = <span class="keyword">new</span> MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, size);</span><br><span class="line">            <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">              memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_CLEAN_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memory;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bufferPoolsBySize.remove(alignedSize);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[numWords];</span><br><span class="line">  MemoryBlock memory = <span class="keyword">new</span> MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, size);</span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_CLEAN_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>è¿™é‡Œå¤šå¤§å†…å­˜æœ‰ä¸€ä¸ªä¼˜åŒ–æœºåˆ¶ï¼Œç±»ä¸­æœ‰ä¸€ä¸ªMapä¼šä¿å­˜å¤§å†…å­˜å—çš„å¼•ç”¨ï¼Œå‡å°‘GCå’Œç”³è¯·å†…å­˜çš„æ—¶é—´ã€‚</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, LinkedList&lt;WeakReference&lt;<span class="keyword">long</span>[]&gt;&gt;&gt; bufferPoolsBySize = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>è§¦å‘è¿™ä¸ªæœºåˆ¶çš„å†…å­˜å¤§å°æ˜¯<code>1024 * 1024</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬èƒ½çœ‹åˆ°åœ¨allocateæ–¹æ³•ä¸­ä¼šå…ˆåˆ¤æ–­æ˜¯å¦è§¦å‘è¯¥æœºåˆ¶ï¼Œå¦‚æœè§¦å‘åˆ™ä»æœªè¢«å›æ”¶çš„å¤§å†…å­˜å—ä¸­å–å‡ºç›¸åº”çš„å—è¿›è¡Œå­˜å‚¨ï¼Œå¦åˆ™ä¼šé‡æ–°ç”³è¯·å†…å­˜ã€‚</p>
<h4 id="Free-page"><a href="#Free-page" class="headerlink" title="Free page"></a>Free page</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freePage</span><span class="params">(MemoryBlock page, MemoryConsumer consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (page.pageNumber != MemoryBlock.NO_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"Called freePage() on memory that wasn't allocated with allocatePage()"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (page.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"Called freePage() on a memory block that has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (page.pageNumber != MemoryBlock.FREED_IN_TMM_PAGE_NUMBER) :</span><br><span class="line">          <span class="string">"Called freePage() on a memory block that has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span>(allocatedPages.get(page.pageNumber));</span><br><span class="line">  pageTable[page.pageNumber] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    allocatedPages.clear(page.pageNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Freed page number &#123;&#125; (&#123;&#125; bytes)"</span>, page.pageNumber, page.size());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> pageSize = page.size();</span><br><span class="line">  <span class="comment">// Clear the page number before passing the block to the MemoryAllocator's free().</span></span><br><span class="line">  <span class="comment">// Doing this allows the MemoryAllocator to detect when a TaskMemoryManager-managed</span></span><br><span class="line">  <span class="comment">// page has been inappropriately directly freed without calling TMM.freePage().</span></span><br><span class="line">  page.pageNumber = MemoryBlock.FREED_IN_TMM_PAGE_NUMBER;</span><br><span class="line">  memoryManager.tungstenMemoryAllocator().free(page);</span><br><span class="line">  releaseExecutionMemory(pageSize, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å¯¹åº”äºç”³è¯·é¡µä¹Ÿä¼šæœ‰é‡Šæ”¾é¡µçš„æ“ä½œï¼Œè¿™ä¸ªè¿‡ç¨‹æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯å¯¹é¡µç›¸å…³çš„æ•°æ®ç»“æ„è¿›è¡Œæ›´æ–°ï¼Œåšä¸€äº›æ¸…ç©ºæ“ä½œã€‚æœ€åä¼šè°ƒç”¨<code>tungstenMemoryAllocator.free</code>è¿›è¡ŒçœŸæ­£çš„é‡Šæ”¾ï¼Œå¹¶ä¸”è°ƒç”¨åº•å±‚çš„ExecutoråŒºçš„poolè¿›è¡Œé‡Šæ”¾ã€‚ä¸‹é¢ä¹Ÿä¼šåˆ†æä¸€ä¸‹on-heapå’Œoff-heapçš„ä¸åŒé‡Šæ”¾æ“ä½œã€‚</p>
<p>::Unsafe memory free::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(MemoryBlock memory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (memory.obj == <span class="keyword">null</span>) :</span><br><span class="line">    <span class="string">"baseObject not null; are you trying to use the off-heap allocator to free on-heap memory?"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"page has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span> ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)</span><br><span class="line">          || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :</span><br><span class="line">    <span class="string">"TMM-allocated pages must be freed via TMM.freePage(), not directly in allocator free()"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  Platform.freeMemory(memory.offset);</span><br><span class="line">  <span class="comment">// As an additional layer of defense against use-after-free bugs, we mutate the</span></span><br><span class="line">  <span class="comment">// MemoryBlock to reset its pointer.</span></span><br><span class="line">  memory.offset = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Mark the page as freed (so we can detect double-frees).</span></span><br><span class="line">  memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>æ•´ä¸ªè¿‡ç¨‹ä¹Ÿå¾ˆç®€å•ï¼Œè°ƒç”¨<code>Unsafe.freeMemory</code>è¿›è¡Œå†…å­˜é‡Šæ”¾ï¼Œå°†é¡µå¯¹è±¡è®¾ç½®ä¸ºä¸€ä¸ªæ¸…ç©ºåçš„çŠ¶æ€ã€‚</p>
<p>::Heap memory free::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(MemoryBlock memory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (memory.obj != <span class="keyword">null</span>) :</span><br><span class="line">    <span class="string">"baseObject was null; are you trying to use the on-heap allocator to free off-heap memory?"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"page has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span> ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)</span><br><span class="line">          || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :</span><br><span class="line">    <span class="string">"TMM-allocated pages must first be freed via TMM.freePage(), not directly in allocator "</span> +</span><br><span class="line">      <span class="string">"free()"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> size = memory.size();</span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the page as freed (so we can detect double-frees).</span></span><br><span class="line">  memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As an additional layer of defense against use-after-free bugs, we mutate the</span></span><br><span class="line">  <span class="comment">// MemoryBlock to null out its reference to the long[] array.</span></span><br><span class="line">  <span class="keyword">long</span>[] array = (<span class="keyword">long</span>[]) memory.obj;</span><br><span class="line">  memory.setObjAndOffset(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> alignedSize = ((size + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (shouldPool(alignedSize)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      LinkedList&lt;WeakReference&lt;<span class="keyword">long</span>[]&gt;&gt; pool = bufferPoolsBySize.get(alignedSize);</span><br><span class="line">      <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        bufferPoolsBySize.put(alignedSize, pool);</span><br><span class="line">      &#125;</span><br><span class="line">      pool.add(<span class="keyword">new</span> WeakReference&lt;&gt;(array));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>å°†å†…å­˜åŒºåŸŸç½®ä¸ºç©ºï¼Œå¦‚æœæ˜¯ä¸€ä¸ªå¤§å†…å­˜å—çš„è¯å°±ä¿ç•™å¼±å¼•ç”¨ï¼Œä»¥ä¾›ä¸‹æ¬¡éœ€è¦çš„æ—¶å€™ç›´æ¥è¿›è¡Œä½¿ç”¨ã€‚ä¸ºäº†åŠ å¤§å‘½ä¸­æ¦‚ç‡å¯ä»¥çœ‹åˆ°åœ¨è®¡ç®—å ç”¨å†…å­˜çš„æ—¶å€™éƒ½ä¼šæ‰¾åˆ°æ¯”å½“å‰å†…å­˜å¤§çš„æœ€è¿‘çš„ä¸€ä¸ª8çš„å€æ•°ï¼Œä¿è¯äº†ä»å¼±å¼•ç”¨åŒºåŸŸä¸­æ‰¾åˆ°çš„ä¸€å®šæ˜¯è¶³å¤Ÿèƒ½è£…çš„ä¸‹æ•°æ®ä¸­æœ€å°çš„ä¸€å—ã€‚</p>
<h2 id="å‚è€ƒ"><a href="#å‚è€ƒ" class="headerlink" title="å‚è€ƒ"></a>å‚è€ƒ</h2><p><a href="https://www.cnblogs.com/johnny666888/p/11197519.html" target="_blank" rel="noopener">spark æºç åˆ†æä¹‹åäº” â€” Sparkå†…å­˜ç®¡ç†å‰–æ - JohnnyBai - åšå®¢å›­</a><br><a href="https://github.com/hustnn/TungstenSecret" target="_blank" rel="noopener">GitHub - hustnn/TungstenSecret: Explore the project Tungsten</a><br><a href="https://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="noopener">Java 6 thread states and life cycle UML protocol state machine diagram example.</a></p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2020/03/22/a17/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2020-09-10 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/spark/">spark<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#ä»£ç æ¸…å•"><span class="toc-article-text">ä»£ç æ¸…å•</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#æ€»è§ˆ"><span class="toc-article-text">æ€»è§ˆ</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Tungsten"><span class="toc-article-text">Tungsten</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memory"><span class="toc-article-text">Memory</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#MemoryManager"><span class="toc-article-text">MemoryManager</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#UnifiedMemoryManager"><span class="toc-article-text">UnifiedMemoryManager</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#MemoryPool"><span class="toc-article-text">MemoryPool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ExecutionMemoryPool"><span class="toc-article-text">ExecutionMemoryPool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#StorageMemoryPool"><span class="toc-article-text">StorageMemoryPool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TaskMemoryManager"><span class="toc-article-text">TaskMemoryManager</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Allocate-page"><span class="toc-article-text">Allocate page</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Free-page"><span class="toc-article-text">Free page</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#å‚è€ƒ"><span class="toc-article-text">å‚è€ƒ</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2020 TalkWithKeyboard
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>â¬†ï¸TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
