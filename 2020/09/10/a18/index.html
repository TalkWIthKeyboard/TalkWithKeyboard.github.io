<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Spark Memory Management | GRYFFONDOR</title>
  <meta name="author" content="TalkWithKeyboard">
  
  <meta name="description" content="本文主要是对Spark的内存管理模块进行了代码走读，从业务逻辑上Spark将内存划分为执行区（Execution区，内存主要用来进行shuffle，join，sort，aggregate的计算）、存储区（Storage区，内存主要用来进行缓存和data transfer）。为了优化JVM内存系统的一">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Spark Memory Management">
  <meta property="og:site_name" content="GRYFFONDOR">

  
    <meta property="og:image" content>
  

  
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">GRYFFONDOR</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Spark Memory Management</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>本文主要是对Spark的内存管理模块进行了代码走读，从业务逻辑上Spark将内存划分为执行区（Execution区，内存主要用来进行shuffle，join，sort，aggregate的计算）、存储区（Storage区，内存主要用来进行缓存和data transfer）。为了优化JVM内存系统的一些问题，在堆内存和堆外内存的基础上抽象了Tungsten内存系统。文中对涉及到的内的关键方法进行了分析。</p>
<h2 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h2><ul>
<li>org.apache.spark.memory.MemoryManager</li>
<li>org.apache.spark.memory.UnifiedMemoryManager</li>
<li>org.apache.spark.memory.MemoryPool</li>
<li>org.apache.spark.memory.ExecutionMemoryPool</li>
<li>org.apache.spark.memory.StorageMemoryPool</li>
<li>org.apache.spark.memory.MemoryConsumer</li>
<li>org.apache.spark.memory.TaskMemoryManager</li>
<li>org.apache.spark.unsafe.memory.MemoryLocation</li>
<li>org.apache.spark.unsafe.memory.MemoryBlock</li>
<li>org.apache.spark.unsafe.memory.MemoryAllocator</li>
<li>org.apache.spark.unsafe.memory.HeapMemoryAllocator</li>
<li>org.apache.spark.unsafe.memory.UnsafeMemoryAllocator</li>
<li>org.apache.spark.storage.memory.MemoryStore</li>
</ul>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img src="/images/a18-1.jpg" alt="a18-1"><br>全局只有唯一一个MemoryManager，里面维护了4个Pool。从业务上分为Execution和Storage，从存储位置分为OnHeap和OffHeap。每个task需要使用多个数据结构，每个数据结构都是一个<code>MemoryConsumer</code>的实现，每个task的这些consumer都通过<code>TaskMemoryManager</code>进行管理，多个<code>TaskMemoryManager</code>共同维护一个<code>Tungsten</code>的页结构。</p>
<h2 id="Tungsten"><a href="#Tungsten" class="headerlink" title="Tungsten"></a>Tungsten</h2><p>为了解决JVM对象存储时的overhead问题，以及GC造成的性能损耗，而提出了一个新的内存模型。提供一套像C/C++一样可以直接操作内存的接口（实际操作的是堆外内存），再为了通用性提供了更高层的接口将堆内存和堆外内存进行了统一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  Object obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MemoryLocation</span><span class="params">(@Nullable Object obj, <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MemoryLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObjAndOffset</span><span class="params">(Object newObj, <span class="keyword">long</span> newOffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.obj = newObj;</span><br><span class="line">    <span class="keyword">this</span>.offset = newOffset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getBaseObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getBaseOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryBlock</span> <span class="keyword">extends</span> <span class="title">MemoryLocation</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> length;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> pageNumber = NO_PAGE_NUMBER;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tungsten提供了一套类似操作系统页内存管理一样的结构，每页会存储一个<code>MemoryBlock</code>结构。<br><code>length</code>是整个Block实际占用的内存大小，<code>pageNumber</code>是在页数组中的index位置。<code>MemoryLocation</code>统一了堆内外内存的寻址，如果是off-heap，则<code>obj</code>为null，<code>offset</code>为绝对内存地址；如果是on-heap，则<code>obj</code>为对象的基地址，<code>offset</code>为偏移量。所以在实际使用过程当中就需要在物理地址与<code>pageNumber</code>,<code>offsetInPage</code>之间进行转换：</p>
<ul>
<li>on-heap: <code>address = page.obj + page.offset + inPageOffset</code></li>
<li>off-heap: <code>address = page.offset + inPageOffset</code></li>
</ul>
<p>但是在这套结构中物理地址不会直接的存储，<code>pageNumer</code> + <code>offsetInPage</code>的组合就能唯一的定位一个值的位置，所以提供了一个编码方法用64位的long值存储这个坐标，前13位是pageNumber，后51位是inPageOffset。在<code>TaskMemoryManager</code>当中提供了多个转换的方法：</p>
<ul>
<li><code>long encodePageNumberAndOffset(MemoryBlock page, long offsetInPage)</code>：给定页和页内偏移量计算encode值</li>
<li><code>long encodePageNumberAndOffset(int pageNumer, long offsetInPage)</code>：给定页号和页内偏移量计算encode值</li>
<li><code>int decodePageNumber(long pagePlusOffsetAddress)</code>：给定encode值，解码pageNumber</li>
<li><code>long decodeOffset(long pagePlusOffsetAddress)</code>：给定encode值，解码offset</li>
<li><code>Object getPage(long pagePlusOffsetAddress)</code>：给定encode值，获取页</li>
<li><code>long getOffsetInPage(long pagePlusOffsetAddress)</code>：给定encode值，获取页内偏移</li>
</ul>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><h3 id="MemoryManager"><a href="#MemoryManager" class="headerlink" title="MemoryManager"></a>MemoryManager</h3><p>该类是内存管理的统筹类，定义了所有的内存管理动作。因为是一个抽象类，所以这些动作有的会下放给实现类实现，有些动作会委托<code>MemoryPool</code>类实现。下面是接口的分类：</p>
<ul>
<li><p>获取内存大小：</p>
<ul>
<li><code>abstract maxOnHeapStorageMemory</code>：获取Storage区最大能使用的堆内存大小（动态变化的）</li>
<li><code>abstract maxOffHeapStorageMemory</code>：获取Storage区最大能使用的堆外内存大小（动态变化的）</li>
<li><code>storageMemoryUsed</code>: Storage区已使用的内存大小</li>
<li><code>onHeapStorageMemoryUsed</code>：Storage区已使用的堆内存大小</li>
<li><code>offHeapStorageMemoryUsed</code>：Storage区已使用的堆外内存大小</li>
<li><code>executionMemoryUsed</code>: Execution区已使用的内存大小</li>
<li><code>onHeapExecutionMemoryUsed</code>：Execution区已使用的堆内存大小</li>
<li><code>offHeapExecutionMemoryUsed</code>：Execution区已使用的堆外内存大小</li>
<li><code>getExecutionMemoryUsageForTask</code>：获取一个task在Execution区占用的内存大小</li>
</ul>
</li>
<li><p>获取更多的内存空间：</p>
<ul>
<li><code>abstract acquireStorageMemory(blockId: BlockId, numBytes: Long, memoryMode: MemoryMode)</code>：为一个Block获取<code>numBytes</code>的Storage区内存空间，如果获取不到足够的空间可能会删除一个存在的Block。</li>
<li><code>abstract acquireExecutionMemory(numBytes: Long, taskAttemptId: Long, memoryMode: MemoryMode)</code>：为一个task获取<code>numBytes</code>的Execution区内存空间，当不能获取到足够执行的内存空间时，这个方法会阻塞，直到获取到足够多的内存。</li>
</ul>
</li>
<li><p>释放内存空间：</p>
<ul>
<li><code>releaseAllExecutionMemoryForTask(taskAttemptId: Long)</code>：释放一个task占用的所有Execution区内存空间</li>
<li><code>releaseStorageMemory(numBytes: Long, memoryMode: MemoryMode)</code>：释放<code>numBytes</code>的Storage区内存空间</li>
<li><code>releaseAllStorageMemory()</code>：释放所有的Storage区内存空间</li>
<li><code>releaseUnrollMemory(numBytes: Long, memoryMode: MemoryMode)</code>：释放<code>numBytes</code>的用于unroll block的内存空间</li>
</ul>
</li>
<li><p><code>Tungsten</code>相关</p>
</li>
</ul>
<h3 id="UnifiedMemoryManager"><a href="#UnifiedMemoryManager" class="headerlink" title="UnifiedMemoryManager"></a>UnifiedMemoryManager</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">UnifiedMemoryManager</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    conf: <span class="type">SparkConf</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val maxHeapMemory: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    onHeapStorageRegionSize: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    numCores: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>构造函数中的：</p>
<ul>
<li><code>maxHeapMemory</code>：是堆内存的总大小</li>
<li><code>onHeapStorageRegionSize</code>：是堆内存中Storage区的起始大小</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">maxOnHeapStorageMemory</span></span>: <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">  maxHeapMemory - onHeapExecutionMemoryPool.memoryUsed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">maxOffHeapStorageMemory</span></span>: <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">  maxOffHeapMemory - offHeapExecutionMemoryPool.memoryUsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法就是简单的计算，不过<code>maxHeapMemory</code>是创建<code>UnifiedMemoryManager</code>时传入的参数，而<code>maxOffHeapMemory</code>是从<code>spark.memory.offHeap.size</code>参数中读入。</p>
<p>::acquireExecutionMemory::<br><code>acquireExecutionMemory</code>中主要的任务就是要给出<code>MemoryPool.acquireMemory()</code>中的两个回调，一个是获取更多的Execution区内存的回调，一个是获取Execution区最多能获取到的内存大小。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybeGrowExecutionPool</span></span>(extraMemoryNeeded: <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (extraMemoryNeeded &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There is not enough free memory in the execution pool, so try to reclaim memory from</span></span><br><span class="line">    <span class="comment">// storage. We can reclaim any free memory from the storage pool. If the storage pool</span></span><br><span class="line">    <span class="comment">// has grown to become larger than `storageRegionSize`, we can evict blocks and reclaim</span></span><br><span class="line">    <span class="comment">// the memory that storage has borrowed from execution.</span></span><br><span class="line">    <span class="keyword">val</span> memoryReclaimableFromStorage = math.max(</span><br><span class="line">      storagePool.memoryFree,</span><br><span class="line">      storagePool.poolSize - storageRegionSize)</span><br><span class="line">    <span class="keyword">if</span> (memoryReclaimableFromStorage &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Only reclaim as much space as is necessary and available:</span></span><br><span class="line">      <span class="keyword">val</span> spaceToReclaim = storagePool.freeSpaceToShrinkPool(</span><br><span class="line">        math.min(extraMemoryNeeded, memoryReclaimableFromStorage))</span><br><span class="line">      storagePool.decrementPoolSize(spaceToReclaim)</span><br><span class="line">      executionPool.incrementPoolSize(spaceToReclaim)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👆获取更多的Execution区内存的回调，这里最重要的是计算可以归还内存大小的逻辑，在<code>memoryFree</code>（空闲的内存大小）和<code>poolSize-storageRegionSize</code>（向Executions区借的内存大小）中取一个更大的值。然后真正归还的内存大小是在<code>memoryReclaimableFromStorage</code>（可以归还的内存大小）和<code>extraMemoryNeeded</code>（Executions区需要扩大的内存大小）之间取一个更小的值。</p>
<p>计算完成以后需要真正的进行内存操作释放需要的内存，该方法在<code>StorageMemoryPool</code>中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeSpaceToShrinkPool</span></span>(spaceToFree: <span class="type">Long</span>): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> spaceFreedByReleasingUnusedMemory = math.min(spaceToFree, memoryFree)</span><br><span class="line">  <span class="keyword">val</span> remainingSpaceToFree = spaceToFree - spaceFreedByReleasingUnusedMemory</span><br><span class="line">  <span class="keyword">if</span> (remainingSpaceToFree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// If reclaiming free memory did not adequately shrink the pool, begin evicting blocks:</span></span><br><span class="line">    <span class="keyword">val</span> spaceFreedByEviction =</span><br><span class="line">      memoryStore.evictBlocksToFreeSpace(<span class="type">None</span>, remainingSpaceToFree, memoryMode)</span><br><span class="line">    <span class="comment">// When a block is released, BlockManager.dropFromMemory() calls releaseMemory(), so we do</span></span><br><span class="line">    <span class="comment">// not need to decrement _memoryUsed here. However, we do need to decrement the pool size.</span></span><br><span class="line">    spaceFreedByReleasingUnusedMemory + spaceFreedByEviction</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    spaceFreedByReleasingUnusedMemory</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<p>先计算空闲空间的大小，如果空闲空间大于等于需要释放的空间大小，则不需要进行内存对象操作。否则的话，需要删除一些内存Block。删除的方法在<code>MemoryStore</code>中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">evictBlocksToFreeSpace</span></span>(</span><br><span class="line">    blockId: <span class="type">Option</span>[<span class="type">BlockId</span>],</span><br><span class="line">    space: <span class="type">Long</span>,</span><br><span class="line">    memoryMode: <span class="type">MemoryMode</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">  assert(space &gt; <span class="number">0</span>)</span><br><span class="line">  memoryManager.synchronized &#123;</span><br><span class="line">    <span class="keyword">var</span> freedMemory = <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">val</span> rddToAdd = blockId.flatMap(getRddId)</span><br><span class="line">    <span class="keyword">val</span> selectedBlocks = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">BlockId</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blockIsEvictable</span></span>(blockId: <span class="type">BlockId</span>, entry: <span class="type">MemoryEntry</span>[_]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">      entry.memoryMode == memoryMode &amp;&amp; (rddToAdd.isEmpty || rddToAdd != getRddId(blockId))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// This is synchronized to ensure that the set of entries is not changed</span></span><br><span class="line">    <span class="comment">// (because of getValue or getBytes) while traversing the iterator, as that</span></span><br><span class="line">    <span class="comment">// can lead to exceptions.</span></span><br><span class="line">    entries.synchronized &#123;</span><br><span class="line">      <span class="keyword">val</span> iterator = entries.entrySet().iterator()</span><br><span class="line">      <span class="keyword">while</span> (freedMemory &lt; space &amp;&amp; iterator.hasNext) &#123;</span><br><span class="line">        <span class="keyword">val</span> pair = iterator.next()</span><br><span class="line">        <span class="keyword">val</span> blockId = pair.getKey</span><br><span class="line">        <span class="keyword">val</span> entry = pair.getValue</span><br><span class="line">        <span class="keyword">if</span> (blockIsEvictable(blockId, entry)) &#123;</span><br><span class="line">          <span class="comment">// We don't want to evict blocks which are currently being read, so we need to obtain</span></span><br><span class="line">          <span class="comment">// an exclusive write lock on blocks which are candidates for eviction. We perform a</span></span><br><span class="line">          <span class="comment">// non-blocking "tryLock" here in order to ignore blocks which are locked for reading:</span></span><br><span class="line">          <span class="keyword">if</span> (blockInfoManager.lockForWriting(blockId, blocking = <span class="literal">false</span>).isDefined) &#123;</span><br><span class="line">            selectedBlocks += blockId</span><br><span class="line">            freedMemory += pair.getValue.size</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dropBlock</span></span>[<span class="type">T</span>](blockId: <span class="type">BlockId</span>, entry: <span class="type">MemoryEntry</span>[<span class="type">T</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> data = entry <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">DeserializedMemoryEntry</span>(values, _, _) =&gt; <span class="type">Left</span>(values)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SerializedMemoryEntry</span>(buffer, _, _) =&gt; <span class="type">Right</span>(buffer)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">val</span> newEffectiveStorageLevel =</span><br><span class="line">        blockEvictionHandler.dropFromMemory(blockId, () =&gt; data)(entry.classTag)</span><br><span class="line">      <span class="keyword">if</span> (newEffectiveStorageLevel.isValid) &#123;</span><br><span class="line">        <span class="comment">// The block is still present in at least one store, so release the lock</span></span><br><span class="line">        <span class="comment">// but don't delete the block info</span></span><br><span class="line">        blockInfoManager.unlock(blockId)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The block isn't present in any store, so delete the block info so that the</span></span><br><span class="line">        <span class="comment">// block can be stored again</span></span><br><span class="line">        blockInfoManager.removeBlock(blockId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freedMemory &gt;= space) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastSuccessfulBlock = <span class="number">-1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        logInfo(<span class="string">s"<span class="subst">$&#123;selectedBlocks.size&#125;</span> blocks selected for dropping "</span> +</span><br><span class="line">          <span class="string">s"(<span class="subst">$&#123;Utils.bytesToString(freedMemory)&#125;</span> bytes)"</span>)</span><br><span class="line">        (<span class="number">0</span> until selectedBlocks.size).foreach &#123; idx =&gt;</span><br><span class="line">          <span class="keyword">val</span> blockId = selectedBlocks(idx)</span><br><span class="line">          <span class="keyword">val</span> entry = entries.synchronized &#123;</span><br><span class="line">            entries.get(blockId)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// This should never be null as only one task should be dropping</span></span><br><span class="line">          <span class="comment">// blocks and removing entries. However the check is still here for</span></span><br><span class="line">          <span class="comment">// future safety.</span></span><br><span class="line">          <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">            dropBlock(blockId, entry)</span><br><span class="line">            afterDropAction(blockId)</span><br><span class="line">          &#125;</span><br><span class="line">          lastSuccessfulBlock = idx</span><br><span class="line">        &#125;</span><br><span class="line">        logInfo(<span class="string">s"After dropping <span class="subst">$&#123;selectedBlocks.size&#125;</span> blocks, "</span> +</span><br><span class="line">          <span class="string">s"free memory is <span class="subst">$&#123;Utils.bytesToString(maxMemory - blocksMemoryUsed)&#125;</span>"</span>)</span><br><span class="line">        freedMemory</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// like BlockManager.doPut, we use a finally rather than a catch to avoid having to deal</span></span><br><span class="line">        <span class="comment">// with InterruptedException</span></span><br><span class="line">        <span class="keyword">if</span> (lastSuccessfulBlock != selectedBlocks.size - <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// the blocks we didn't process successfully are still locked, so we have to unlock them</span></span><br><span class="line">          (lastSuccessfulBlock + <span class="number">1</span> until selectedBlocks.size).foreach &#123; idx =&gt;</span><br><span class="line">            <span class="keyword">val</span> blockId = selectedBlocks(idx)</span><br><span class="line">            blockInfoManager.unlock(blockId)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      blockId.foreach &#123; id =&gt;</span><br><span class="line">        logInfo(<span class="string">s"Will not store <span class="subst">$id</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      selectedBlocks.foreach &#123; id =&gt;</span><br><span class="line">        blockInfoManager.unlock(id)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">0</span>L</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类当中有一个存储所有Block的Map，即：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> entries = <span class="keyword">new</span> <span class="type">LinkedHashMap</span>[<span class="type">BlockId</span>, <span class="type">MemoryEntry</span>[_]](<span class="number">32</span>, <span class="number">0.75</span>f, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p><code>LinkedHashMap</code>不是线程安全的，所以每次操作之前也是需要加锁。如果没有获取到需要释放的内存空间大小则遍历Block，判断遍历的Block与需要存储的Block是否是同一个存储区域（还判断了遍历的Block与需要存储的Block是否是同一个），如果通过了判断则需要先将该Block锁住，加入候选名单。</p>
<p>找够所有的候选者以后还没有达到需要释放的内存空间大小则将所有锁住的Block解锁，返回0，表示这个操作失败。如果达到了，则开始释放内存的过程。将每一个Block执行<code>dropBlock</code>，<code>afterDropAction</code>的操作。在<code>dropBlock</code>中会删除该Block本身的数据（除非Block还在被操作），检查Block是否还在被其他的storage存储，如果是的话就先不删除其metadata，否则的话继续删除metadata。<code>afterDropAction</code>是个hook，可以由调用方指定删除之后的动作。如果在删除过程当中失败的话，需要将没有删除的Block解锁。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeMaxExecutionPoolSize</span></span>(): <span class="type">Long</span> = &#123;</span><br><span class="line">  maxMemory - math.min(storagePool.memoryUsed, storageRegionSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👆获取Execution区最多能获取到的内存大小，是通过最大的内存大小减去Storage区最大能占用的内存大小。Storage区能占用的上限是<code>storageRegionSize</code>。</p>
<p>下面来看真正进行内存分配的函数<code>acquireMemory</code>，该方法在<code>ExecutionMemoryPool</code>中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[memory] <span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(</span><br><span class="line">    numBytes: <span class="type">Long</span>,</span><br><span class="line">    taskAttemptId: <span class="type">Long</span>,</span><br><span class="line">    maybeGrowPool: <span class="type">Long</span> =&gt; <span class="type">Unit</span> = (additionalSpaceNeeded: <span class="type">Long</span>) =&gt; (),</span><br><span class="line">    computeMaxPoolSize: () =&gt; <span class="type">Long</span> = () =&gt; poolSize): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  assert(numBytes &gt; <span class="number">0</span>, <span class="string">s"invalid number of bytes requested: <span class="subst">$numBytes</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> clean up this clunky method signature</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add this task to the taskMemory map just so we can keep an accurate count of the number</span></span><br><span class="line">  <span class="comment">// of active tasks, to let other tasks ramp down their memory in calls to `acquireMemory`</span></span><br><span class="line">  <span class="keyword">if</span> (!memoryForTask.contains(taskAttemptId)) &#123;</span><br><span class="line">    memoryForTask(taskAttemptId) = <span class="number">0</span>L</span><br><span class="line">    <span class="comment">// This will later cause waiting tasks to wake up and check numTasks again</span></span><br><span class="line">    lock.notifyAll()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Keep looping until we're either sure that we don't want to grant this request (because this</span></span><br><span class="line">  <span class="comment">// task would have more than 1 / numActiveTasks of the memory) or we have enough free</span></span><br><span class="line">  <span class="comment">// memory to give it (we always let each task get at least 1 / (2 * numActiveTasks)).</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> simplify this to limit each task to its own slot</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> numActiveTasks = memoryForTask.keys.size</span><br><span class="line">    <span class="keyword">val</span> curMem = memoryForTask(taskAttemptId)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In every iteration of this loop, we should first try to reclaim any borrowed execution</span></span><br><span class="line">    <span class="comment">// space from storage. This is necessary because of the potential race condition where new</span></span><br><span class="line">    <span class="comment">// storage blocks may steal the free execution memory that this task was waiting for.</span></span><br><span class="line">    maybeGrowPool(numBytes - memoryFree)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maximum size the pool would have after potentially growing the pool.</span></span><br><span class="line">    <span class="comment">// This is used to compute the upper bound of how much memory each task can occupy. This</span></span><br><span class="line">    <span class="comment">// must take into account potential free memory as well as the amount this pool currently</span></span><br><span class="line">    <span class="comment">// occupies. Otherwise, we may run into SPARK-12155 where, in unified memory management,</span></span><br><span class="line">    <span class="comment">// we did not take into account space that could have been freed by evicting cached blocks.</span></span><br><span class="line">    <span class="keyword">val</span> maxPoolSize = computeMaxPoolSize()</span><br><span class="line">    <span class="keyword">val</span> maxMemoryPerTask = maxPoolSize / numActiveTasks</span><br><span class="line">    <span class="keyword">val</span> minMemoryPerTask = poolSize / (<span class="number">2</span> * numActiveTasks)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// How much we can grant this task; keep its share within 0 &lt;= X &lt;= 1 / numActiveTasks</span></span><br><span class="line">    <span class="keyword">val</span> maxToGrant = math.min(numBytes, math.max(<span class="number">0</span>, maxMemoryPerTask - curMem))</span><br><span class="line">    <span class="comment">// Only give it as much memory as is free, which might be none if it reached 1 / numTasks</span></span><br><span class="line">    <span class="keyword">val</span> toGrant = math.min(maxToGrant, memoryFree)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We want to let each task get at least 1 / (2 * numActiveTasks) before blocking;</span></span><br><span class="line">    <span class="comment">// if we can't give it this much now, wait for other tasks to free up memory</span></span><br><span class="line">    <span class="comment">// (this happens if older tasks allocated lots of memory before N grew)</span></span><br><span class="line">    <span class="keyword">if</span> (toGrant &lt; numBytes &amp;&amp; curMem + toGrant &lt; minMemoryPerTask) &#123;</span><br><span class="line">      logInfo(<span class="string">s"TID <span class="subst">$taskAttemptId</span> waiting for at least 1/2N of <span class="subst">$poolName</span> pool to be free"</span>)</span><br><span class="line">      lock.wait()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memoryForTask(taskAttemptId) += toGrant</span><br><span class="line">      <span class="keyword">return</span> toGrant</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">0</span>L  <span class="comment">// Never reached</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先关注一下锁的对象，在调用方<code>MemoryManager</code>初始化的时候有声明锁的对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> onHeapStorageMemoryPool = <span class="keyword">new</span> <span class="type">StorageMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span>)</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> offHeapStorageMemoryPool = <span class="keyword">new</span> <span class="type">StorageMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span>)</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> onHeapExecutionMemoryPool = <span class="keyword">new</span> <span class="type">ExecutionMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span>)</span><br><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">val</span> offHeapExecutionMemoryPool = <span class="keyword">new</span> <span class="type">ExecutionMemoryPool</span>(<span class="keyword">this</span>, <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[memory] <span class="class"><span class="keyword">class</span> <span class="title">ExecutionMemoryPool</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    lock: <span class="type">Object</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    memoryMode: <span class="type">MemoryMode</span></span></span></span><br><span class="line"><span class="class"><span class="params">  </span>)</span></span><br></pre></td></tr></table></figure>

<p>通过上面两个代码片段可以看出，多个Pool的锁对象都是<code>MemoryManger</code>，所以多个Pool之间是互斥的，不论是<code>StorageMemoryPool</code>还是<code>ExecutionMemoryPool</code>。</p>
<p>然后整个函数的工作方式：</p>
<ul>
<li>如果是一个新的task，先帮它加入到<code>memoryForTask</code>中，内存设为0，然后唤醒所有等待队列里的线程开始等锁。<code>memoryForTask</code>是一个保存<code>taskId -&gt; memory</code>的map。</li>
<li>进入一个死循环中，先查看是否需要获取更多的内存，如果需要的话则调用<code>maybeGrowPool</code>回调。计算一个task理论能分配到的最大内存和最小内存，即<code>1/2N * maxPoolSize &lt;= cache &lt;= 1/N * maxPoolSize</code>。接着计算实际最大能分配到的内存以及最终实际分配的内存。</li>
<li>如果实际分配到的内存小于需要的内存或者这个任务分配到的总内存都没有达到理论最小内存的话，则将锁还掉以后继续等锁。如果拿到了需要的内存以后就更新<code>memoryForTask</code>并进行返回。</li>
</ul>
<p>::acquireStorageMemory::</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">acquireStorageMemory</span></span>(</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    numBytes: <span class="type">Long</span>,</span><br><span class="line">    memoryMode: <span class="type">MemoryMode</span>): <span class="type">Boolean</span> = synchronized &#123;</span><br><span class="line">  assertInvariants()</span><br><span class="line">  assert(numBytes &gt;= <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">val</span> (executionPool, storagePool, maxMemory) = memoryMode <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MemoryMode</span>.<span class="type">ON_HEAP</span> =&gt; (</span><br><span class="line">      onHeapExecutionMemoryPool,</span><br><span class="line">      onHeapStorageMemoryPool,</span><br><span class="line">      maxOnHeapStorageMemory)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MemoryMode</span>.<span class="type">OFF_HEAP</span> =&gt; (</span><br><span class="line">      offHeapExecutionMemoryPool,</span><br><span class="line">      offHeapStorageMemoryPool,</span><br><span class="line">      maxOffHeapStorageMemory)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numBytes &gt; maxMemory) &#123;</span><br><span class="line">    <span class="comment">// Fail fast if the block simply won't fit</span></span><br><span class="line">    logInfo(<span class="string">s"Will not store <span class="subst">$blockId</span> as the required space (<span class="subst">$numBytes</span> bytes) exceeds our "</span> +</span><br><span class="line">      <span class="string">s"memory limit (<span class="subst">$maxMemory</span> bytes)"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (numBytes &gt; storagePool.memoryFree) &#123;</span><br><span class="line">    <span class="comment">// There is not enough free memory in the storage pool, so try to borrow free memory from</span></span><br><span class="line">    <span class="comment">// the execution pool.</span></span><br><span class="line">    <span class="keyword">val</span> memoryBorrowedFromExecution = <span class="type">Math</span>.min(executionPool.memoryFree,</span><br><span class="line">      numBytes - storagePool.memoryFree)</span><br><span class="line">    executionPool.decrementPoolSize(memoryBorrowedFromExecution)</span><br><span class="line">    storagePool.incrementPoolSize(memoryBorrowedFromExecution)</span><br><span class="line">  &#125;</span><br><span class="line">  storagePool.acquireMemory(blockId, numBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要申请的内存大于最大内存则返回false，申请的内存大于Storage区的剩余内存，则需要从Execution区借内存。Storage区不能将正在运行的task踢出Execution区，所以只能从中获取空闲的空间大小。数值计算完成以后，开始真正的分配。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    numBytesToAcquire: <span class="type">Long</span>,</span><br><span class="line">    numBytesToFree: <span class="type">Long</span>): <span class="type">Boolean</span> = lock.synchronized &#123;</span><br><span class="line">  assert(numBytesToAcquire &gt;= <span class="number">0</span>)</span><br><span class="line">  assert(numBytesToFree &gt;= <span class="number">0</span>)</span><br><span class="line">  assert(memoryUsed &lt;= poolSize)</span><br><span class="line">  <span class="keyword">if</span> (numBytesToFree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    memoryStore.evictBlocksToFreeSpace(<span class="type">Some</span>(blockId), numBytesToFree, memoryMode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> If the memory store evicts blocks, then those evictions will synchronously call</span></span><br><span class="line">  <span class="comment">// back into this StorageMemoryPool in order to free memory. Therefore, these variables</span></span><br><span class="line">  <span class="comment">// should have been updated.</span></span><br><span class="line">  <span class="keyword">val</span> enoughMemory = numBytesToAcquire &lt;= memoryFree</span><br><span class="line">  <span class="keyword">if</span> (enoughMemory) &#123;</span><br><span class="line">    _memoryUsed += numBytesToAcquire</span><br><span class="line">  &#125;</span><br><span class="line">  enoughMemory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从Storage中删除一些Block释放一些内存，如果有足够的内存申请就更新已使用的内存计数器，否则直接返回false。</p>
<h3 id="MemoryPool"><a href="#MemoryPool" class="headerlink" title="MemoryPool"></a>MemoryPool</h3><p>这是一个抽象类，整个类都在维护一个变量<code>_poolSize</code>，表示内存使用量。提供了维护这个量的一些方法，如：</p>
<ul>
<li><code>poolSize: Long</code>：获取<code>_poolSize</code></li>
<li><code>memoryFree: Long</code>：获取空闲的内存空间大小</li>
<li><code>incrementPoolSize(delta: Long)</code>：提高<code>_poolSize</code></li>
<li><code>decrementPoolSize(delta: Long)</code>：降低<code>_poolSize</code></li>
</ul>
<p>以及一个抽象方法：</p>
<ul>
<li><code>memoryUsed: Long</code></li>
</ul>
<h3 id="ExecutionMemoryPool"><a href="#ExecutionMemoryPool" class="headerlink" title="ExecutionMemoryPool"></a>ExecutionMemoryPool</h3><p>该类中维护了一个<code>taskId -&gt; memory</code>的Map：<code>memoryForTask</code>来管理内存。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">memoryUsed</span></span>: <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  memoryForTask.values.sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现父类的抽象方法，直接将<code>memoryForTask</code>中的values累加。</p>
<p><code>acquireMemory</code>已经在上文中分析过了。<code>releaseMemory</code>在<code>MemoryManager.releaseExecutionMemory</code>中被调用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseMemory</span></span>(numBytes: <span class="type">Long</span>, taskAttemptId: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> curMem = memoryForTask.getOrElse(taskAttemptId, <span class="number">0</span>L)</span><br><span class="line">  <span class="keyword">val</span> memoryToFree = <span class="keyword">if</span> (curMem &lt; numBytes) &#123;</span><br><span class="line">    logWarning(</span><br><span class="line">      <span class="string">s"Internal error: release called on <span class="subst">$numBytes</span> bytes but task only has <span class="subst">$curMem</span> bytes "</span> +</span><br><span class="line">        <span class="string">s"of memory from the <span class="subst">$poolName</span> pool"</span>)</span><br><span class="line">    curMem</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    numBytes</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (memoryForTask.contains(taskAttemptId)) &#123;</span><br><span class="line">    memoryForTask(taskAttemptId) -= memoryToFree</span><br><span class="line">    <span class="keyword">if</span> (memoryForTask(taskAttemptId) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      memoryForTask.remove(taskAttemptId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lock.notifyAll() <span class="comment">// Notify waiters in acquireMemory() that memory has been freed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在正式释放之前会先比较一下现在该task所占用的内存和需要释放的内存的大小，如果task所占内存小于需要释放的内存也只会释放task所占内存，不会再释放其他的task。因为有新的内存空间出现，所以可以唤醒等待队列里的线程，开始给新任务争取内存。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseAllMemoryForTask</span></span>(taskAttemptId: <span class="type">Long</span>): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> numBytesToFree = getMemoryUsageForTask(taskAttemptId)</span><br><span class="line">  releaseMemory(numBytesToFree, taskAttemptId)</span><br><span class="line">  numBytesToFree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法会释放一个task所有的内存，直接获取task所占用的内存以后调用上面的<code>releaseMemory</code>方法。</p>
<h3 id="StorageMemoryPool"><a href="#StorageMemoryPool" class="headerlink" title="StorageMemoryPool"></a>StorageMemoryPool</h3><p>该类负责Storage区的内存管理，在类中维护了一个<code>_memoryUsed</code>参数，来表示使用了多少内存。并且会关联一个<code>MemoryStore</code>对象，该对象会完成真正的内存管理操作。</p>
<p>重要的<code>acquireMemory</code>和<code>freeSpaceToShrinkPool</code>函数均在上文中进行了介绍。</p>
<h3 id="TaskMemoryManager"><a href="#TaskMemoryManager" class="headerlink" title="TaskMemoryManager"></a>TaskMemoryManager</h3><p>该类负责管理一个task的内存，该类中不会直接操作内存，会通过<code>MemoryManager</code>来进行管理。不过因为底层使用了<code>Tungsten</code>内存模型，该类中还会维护内存模型使用的页机制相关的变量。所有的<code>TaskMemoryManager</code>会共用一个<code>MemoryManager</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">acquireExecutionMemory</span><span class="params">(<span class="keyword">long</span> required, MemoryConsumer consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span>(required &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">assert</span>(consumer != <span class="keyword">null</span>);</span><br><span class="line">  MemoryMode mode = consumer.getMode();</span><br><span class="line">  <span class="comment">// If we are allocating Tungsten pages off-heap and receive a request to allocate on-heap</span></span><br><span class="line">  <span class="comment">// memory here, then it may not make sense to spill since that would only end up freeing</span></span><br><span class="line">  <span class="comment">// off-heap memory. This is subject to change, though, so it may be risky to make this</span></span><br><span class="line">  <span class="comment">// optimization now in case we forget to undo it late when making changes.</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> got = memoryManager.acquireExecutionMemory(required, taskAttemptId, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to release memory from other consumers first, then we can reduce the frequency of</span></span><br><span class="line">    <span class="comment">// spilling, avoid to have too many spilled files.</span></span><br><span class="line">    <span class="keyword">if</span> (got &lt; required) &#123;</span><br><span class="line">      <span class="comment">// Call spill() on other consumers to release memory</span></span><br><span class="line">      <span class="comment">// Sort the consumers according their memory usage. So we avoid spilling the same consumer</span></span><br><span class="line">      <span class="comment">// which is just spilled in last few times and re-spilling on it will produce many small</span></span><br><span class="line">      <span class="comment">// spill files.</span></span><br><span class="line">      TreeMap&lt;Long, List&lt;MemoryConsumer&gt;&gt; sortedConsumers = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (MemoryConsumer c: consumers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c != consumer &amp;&amp; c.getUsed() &gt; <span class="number">0</span> &amp;&amp; c.getMode() == mode) &#123;</span><br><span class="line">          <span class="keyword">long</span> key = c.getUsed();</span><br><span class="line">          List&lt;MemoryConsumer&gt; list =</span><br><span class="line">              sortedConsumers.computeIfAbsent(key, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>));</span><br><span class="line">          list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (!sortedConsumers.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// Get the consumer using the least memory more than the remaining required memory.</span></span><br><span class="line">        Map.Entry&lt;Long, List&lt;MemoryConsumer&gt;&gt; currentEntry =</span><br><span class="line">          sortedConsumers.ceilingEntry(required - got);</span><br><span class="line">        <span class="comment">// No consumer has used memory more than the remaining required memory.</span></span><br><span class="line">        <span class="comment">// Get the consumer of largest used memory.</span></span><br><span class="line">        <span class="keyword">if</span> (currentEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">          currentEntry = sortedConsumers.lastEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;MemoryConsumer&gt; cList = currentEntry.getValue();</span><br><span class="line">        MemoryConsumer c = cList.get(cList.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">long</span> released = c.spill(required - got, consumer);</span><br><span class="line">          <span class="keyword">if</span> (released &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Task &#123;&#125; released &#123;&#125; from &#123;&#125; for &#123;&#125;"</span>, taskAttemptId,</span><br><span class="line">              Utils.bytesToString(released), c, consumer);</span><br><span class="line">            got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId, mode);</span><br><span class="line">            <span class="keyword">if</span> (got &gt;= required) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cList.remove(cList.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (cList.isEmpty()) &#123;</span><br><span class="line">              sortedConsumers.remove(currentEntry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClosedByInterruptException e) &#123;</span><br><span class="line">          <span class="comment">// This called by user to kill a task (e.g: speculative task).</span></span><br><span class="line">          logger.error(<span class="string">"error while calling spill() on "</span> + c, e);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          logger.error(<span class="string">"error while calling spill() on "</span> + c, e);</span><br><span class="line">          <span class="comment">// checkstyle.off: RegexpSinglelineJava</span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SparkOutOfMemoryError(<span class="string">"error while calling spill() on "</span> + c + <span class="string">" : "</span></span><br><span class="line">            + e.getMessage());</span><br><span class="line">          <span class="comment">// checkstyle.on: RegexpSinglelineJava</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// call spill() on itself</span></span><br><span class="line">    <span class="keyword">if</span> (got &lt; required) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> released = consumer.spill(required - got, consumer);</span><br><span class="line">        <span class="keyword">if</span> (released &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Task &#123;&#125; released &#123;&#125; from itself (&#123;&#125;)"</span>, taskAttemptId,</span><br><span class="line">            Utils.bytesToString(released), consumer);</span><br><span class="line">          got += memoryManager.acquireExecutionMemory(required - got, taskAttemptId, mode);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClosedByInterruptException e) &#123;</span><br><span class="line">        <span class="comment">// This called by user to kill a task (e.g: speculative task).</span></span><br><span class="line">        logger.error(<span class="string">"error while calling spill() on "</span> + consumer, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"error while calling spill() on "</span> + consumer, e);</span><br><span class="line">        <span class="comment">// checkstyle.off: RegexpSinglelineJava</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SparkOutOfMemoryError(<span class="string">"error while calling spill() on "</span> + consumer + <span class="string">" : "</span></span><br><span class="line">          + e.getMessage());</span><br><span class="line">        <span class="comment">// checkstyle.on: RegexpSinglelineJava</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumers.add(consumer);</span><br><span class="line">    logger.debug(<span class="string">"Task &#123;&#125; acquired &#123;&#125; for &#123;&#125;"</span>, taskAttemptId, Utils.bytesToString(got), consumer);</span><br><span class="line">    <span class="keyword">return</span> got;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法是为一个task新的consumer分配内存，一进来会先尝试使用ExecutorPool申请<code>required</code>大小的内存，如果能直接获取到就结束。否则的话需要从consumer中挑选合适的consumer进行spill操作（也就是将内存中的数据冲写到硬盘上）来释放足够多的内存。</p>
<p>挑选的过程也很常规，会选出大于需要的内存的consumer中最小的一个，如果不存在则从大到小依次spill，直到释放的内存达到需求。不过筛选大于需要的内存中最小的一个用了一个很简洁快速的方式，创建了一个<code>memory -&gt; List&lt;MemoryConsumer&gt;</code>的TreeMap，直接使用<code>TreeMap.ceilingEntry</code>方法。每次释放完成以后都再重新申请更多的内存，直到申请到了足够多的内存。</p>
<p>如果在上面的操作执行完成以后（也就是能释放的都释放掉了）还是不够，那么就将这个要加入的新的consumer的部分数据冲写到硬盘上，使他能被放入MemoryPool中。</p>
<h4 id="Allocate-page"><a href="#Allocate-page" class="headerlink" title="Allocate page"></a>Allocate page</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MemoryBlock <span class="title">allocatePage</span><span class="params">(<span class="keyword">long</span> size, MemoryConsumer consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span>(consumer != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(consumer.getMode() == tungstenMemoryMode);</span><br><span class="line">  <span class="keyword">if</span> (size &gt; MAXIMUM_PAGE_SIZE_BYTES) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TooLargePageException(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> acquired = acquireExecutionMemory(size, consumer);</span><br><span class="line">  <span class="keyword">if</span> (acquired &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> pageNumber;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    pageNumber = allocatedPages.nextClearBit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pageNumber &gt;= PAGE_TABLE_SIZE) &#123;</span><br><span class="line">      releaseExecutionMemory(acquired, consumer);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Have already allocated a maximum of "</span> + PAGE_TABLE_SIZE + <span class="string">" pages"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    allocatedPages.set(pageNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  MemoryBlock page = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    page = memoryManager.tungstenMemoryAllocator().allocate(acquired);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">    logger.warn(<span class="string">"Failed to allocate a page (&#123;&#125; bytes), try again."</span>, acquired);</span><br><span class="line">    <span class="comment">// there is no enough memory actually, it means the actual free memory is smaller than</span></span><br><span class="line">    <span class="comment">// MemoryManager thought, we should keep the acquired memory.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      acquiredButNotUsed += acquired;</span><br><span class="line">      allocatedPages.clear(pageNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// this could trigger spilling to free some pages.</span></span><br><span class="line">    <span class="keyword">return</span> allocatePage(size, consumer);</span><br><span class="line">  &#125;</span><br><span class="line">  page.pageNumber = pageNumber;</span><br><span class="line">  pageTable[pageNumber] = page;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Allocate page number &#123;&#125; (&#123;&#125; bytes)"</span>, pageNumber, acquired);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>页管理主要由一个 <code>BitSet</code>（标示页位情况）和<code>MemoryBlock[]</code>（）实现，true表示页位被占。该方法会先调用<code>acquireExecutionMemory</code>申请实际的物理内存，然后通过<code>BitSet.nextClearBit（）</code>函数获取第一个空位置，并进行占位。完成以后就会通过<code>tungstenMemoryAllocator</code>来真正进行内存申请，下面会分析一下on-heap和off-heap两种不同的内存申请：</p>
<p>::Unsafe memory allocate::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MemoryBlock <span class="title">allocate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> OutOfMemoryError </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> address = Platform.allocateMemory(size);</span><br><span class="line">  MemoryBlock memory = <span class="keyword">new</span> MemoryBlock(<span class="keyword">null</span>, address, size);</span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_CLEAN_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Off-heap的所有内存操作都是通过Unsafe工具类来完成，这个方法非常的简单。会先通过<code>Unsafe.allocateMemory</code>申请内存，然后初始化一个页结构，off-heap不会映射对象，所以obj传入null即可。</p>
<p>::Heap memory allocate::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MemoryBlock <span class="title">allocate</span><span class="params">(<span class="keyword">long</span> size)</span> <span class="keyword">throws</span> OutOfMemoryError </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> numWords = (<span class="keyword">int</span>) ((size + <span class="number">7</span>) / <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">long</span> alignedSize = numWords * <span class="number">8L</span>;</span><br><span class="line">  <span class="keyword">assert</span> (alignedSize &gt;= size);</span><br><span class="line">  <span class="keyword">if</span> (shouldPool(alignedSize)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> LinkedList&lt;WeakReference&lt;<span class="keyword">long</span>[]&gt;&gt; pool = bufferPoolsBySize.get(alignedSize);</span><br><span class="line">      <span class="keyword">if</span> (pool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!pool.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">final</span> WeakReference&lt;<span class="keyword">long</span>[]&gt; arrayReference = pool.pop();</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span>[] array = arrayReference.get();</span><br><span class="line">          <span class="keyword">if</span> (array != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">assert</span> (array.length * <span class="number">8L</span> &gt;= size);</span><br><span class="line">            MemoryBlock memory = <span class="keyword">new</span> MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, size);</span><br><span class="line">            <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">              memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_CLEAN_VALUE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> memory;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        bufferPoolsBySize.remove(alignedSize);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span>[] array = <span class="keyword">new</span> <span class="keyword">long</span>[numWords];</span><br><span class="line">  MemoryBlock memory = <span class="keyword">new</span> MemoryBlock(array, Platform.LONG_ARRAY_OFFSET, size);</span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_CLEAN_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多大内存有一个优化机制，类中有一个Map会保存大内存块的引用，减少GC和申请内存的时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, LinkedList&lt;WeakReference&lt;<span class="keyword">long</span>[]&gt;&gt;&gt; bufferPoolsBySize = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>触发这个机制的内存大小是<code>1024 * 1024</code>，所以我们能看到在allocate方法中会先判断是否触发该机制，如果触发则从未被回收的大内存块中取出相应的块进行存储，否则会重新申请内存。</p>
<h4 id="Free-page"><a href="#Free-page" class="headerlink" title="Free page"></a>Free page</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freePage</span><span class="params">(MemoryBlock page, MemoryConsumer consumer)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (page.pageNumber != MemoryBlock.NO_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"Called freePage() on memory that wasn't allocated with allocatePage()"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (page.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"Called freePage() on a memory block that has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (page.pageNumber != MemoryBlock.FREED_IN_TMM_PAGE_NUMBER) :</span><br><span class="line">          <span class="string">"Called freePage() on a memory block that has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span>(allocatedPages.get(page.pageNumber));</span><br><span class="line">  pageTable[page.pageNumber] = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    allocatedPages.clear(page.pageNumber);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Freed page number &#123;&#125; (&#123;&#125; bytes)"</span>, page.pageNumber, page.size());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> pageSize = page.size();</span><br><span class="line">  <span class="comment">// Clear the page number before passing the block to the MemoryAllocator's free().</span></span><br><span class="line">  <span class="comment">// Doing this allows the MemoryAllocator to detect when a TaskMemoryManager-managed</span></span><br><span class="line">  <span class="comment">// page has been inappropriately directly freed without calling TMM.freePage().</span></span><br><span class="line">  page.pageNumber = MemoryBlock.FREED_IN_TMM_PAGE_NUMBER;</span><br><span class="line">  memoryManager.tungstenMemoryAllocator().free(page);</span><br><span class="line">  releaseExecutionMemory(pageSize, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应于申请页也会有释放页的操作，这个过程比较简单，就是对页相关的数据结构进行更新，做一些清空操作。最后会调用<code>tungstenMemoryAllocator.free</code>进行真正的释放，并且调用底层的Executor区的pool进行释放。下面也会分析一下on-heap和off-heap的不同释放操作。</p>
<p>::Unsafe memory free::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(MemoryBlock memory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (memory.obj == <span class="keyword">null</span>) :</span><br><span class="line">    <span class="string">"baseObject not null; are you trying to use the off-heap allocator to free on-heap memory?"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"page has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span> ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)</span><br><span class="line">          || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :</span><br><span class="line">    <span class="string">"TMM-allocated pages must be freed via TMM.freePage(), not directly in allocator free()"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  Platform.freeMemory(memory.offset);</span><br><span class="line">  <span class="comment">// As an additional layer of defense against use-after-free bugs, we mutate the</span></span><br><span class="line">  <span class="comment">// MemoryBlock to reset its pointer.</span></span><br><span class="line">  memory.offset = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Mark the page as freed (so we can detect double-frees).</span></span><br><span class="line">  memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个过程也很简单，调用<code>Unsafe.freeMemory</code>进行内存释放，将页对象设置为一个清空后的状态。</p>
<p>::Heap memory free::</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(MemoryBlock memory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">assert</span> (memory.obj != <span class="keyword">null</span>) :</span><br><span class="line">    <span class="string">"baseObject was null; are you trying to use the on-heap allocator to free off-heap memory?"</span>;</span><br><span class="line">  <span class="keyword">assert</span> (memory.pageNumber != MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER) :</span><br><span class="line">    <span class="string">"page has already been freed"</span>;</span><br><span class="line">  <span class="keyword">assert</span> ((memory.pageNumber == MemoryBlock.NO_PAGE_NUMBER)</span><br><span class="line">          || (memory.pageNumber == MemoryBlock.FREED_IN_TMM_PAGE_NUMBER)) :</span><br><span class="line">    <span class="string">"TMM-allocated pages must first be freed via TMM.freePage(), not directly in allocator "</span> +</span><br><span class="line">      <span class="string">"free()"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> size = memory.size();</span><br><span class="line">  <span class="keyword">if</span> (MemoryAllocator.MEMORY_DEBUG_FILL_ENABLED) &#123;</span><br><span class="line">    memory.fill(MemoryAllocator.MEMORY_DEBUG_FILL_FREED_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the page as freed (so we can detect double-frees).</span></span><br><span class="line">  memory.pageNumber = MemoryBlock.FREED_IN_ALLOCATOR_PAGE_NUMBER;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As an additional layer of defense against use-after-free bugs, we mutate the</span></span><br><span class="line">  <span class="comment">// MemoryBlock to null out its reference to the long[] array.</span></span><br><span class="line">  <span class="keyword">long</span>[] array = (<span class="keyword">long</span>[]) memory.obj;</span><br><span class="line">  memory.setObjAndOffset(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> alignedSize = ((size + <span class="number">7</span>) / <span class="number">8</span>) * <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (shouldPool(alignedSize)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      LinkedList&lt;WeakReference&lt;<span class="keyword">long</span>[]&gt;&gt; pool = bufferPoolsBySize.get(alignedSize);</span><br><span class="line">      <span class="keyword">if</span> (pool == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pool = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        bufferPoolsBySize.put(alignedSize, pool);</span><br><span class="line">      &#125;</span><br><span class="line">      pool.add(<span class="keyword">new</span> WeakReference&lt;&gt;(array));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将内存区域置为空，如果是一个大内存块的话就保留弱引用，以供下次需要的时候直接进行使用。为了加大命中概率可以看到在计算占用内存的时候都会找到比当前内存大的最近的一个8的倍数，保证了从弱引用区域中找到的一定是足够能装的下数据中最小的一块。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/johnny666888/p/11197519.html" target="_blank" rel="noopener">spark 源码分析之十五 — Spark内存管理剖析 - JohnnyBai - 博客园</a><br><a href="https://github.com/hustnn/TungstenSecret" target="_blank" rel="noopener">GitHub - hustnn/TungstenSecret: Explore the project Tungsten</a><br><a href="https://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="noopener">Java 6 thread states and life cycle UML protocol state machine diagram example.</a></p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a type="button" class="btn btn-default disabled"><i class="fa fa-arrow-circle-o-left"></i>Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2020/03/22/a17/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <h2 class="title">Comments</h2>

    
</section>


	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2020-09-10 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/spark/">spark<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#代码清单"><span class="toc-article-text">代码清单</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#总览"><span class="toc-article-text">总览</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Tungsten"><span class="toc-article-text">Tungsten</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Memory"><span class="toc-article-text">Memory</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#MemoryManager"><span class="toc-article-text">MemoryManager</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#UnifiedMemoryManager"><span class="toc-article-text">UnifiedMemoryManager</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#MemoryPool"><span class="toc-article-text">MemoryPool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#ExecutionMemoryPool"><span class="toc-article-text">ExecutionMemoryPool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#StorageMemoryPool"><span class="toc-article-text">StorageMemoryPool</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#TaskMemoryManager"><span class="toc-article-text">TaskMemoryManager</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Allocate-page"><span class="toc-article-text">Allocate page</span></a></li><li class="toc-article-item toc-article-level-4"><a class="toc-article-link" href="#Free-page"><span class="toc-article-text">Free page</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#参考"><span class="toc-article-text">参考</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2020 TalkWithKeyboard
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> and <a href="http://getbootstrap.com/" target="_blank">BOOTSTRA.386</a>. 
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
